mpif90 -O3 -fimplicit-none -Wall -o ../bin/sord-mO globals.f90 diffcn.f90 diffnc.f90 hourglass.f90 bc.f90 surfnormals.f90 util.f90 frio.f90 mpi.f90 arrays.f90 fieldio.f90 stats.f90 parameters.f90 setup.f90 gridgen.f90 material.f90 source.f90 inivolstress.f90 rupture.f90 resample.f90 checkpoint.f90 timestep.f90 stress.f90 acceleration.f90 sord.f90
! Global variables
module m_globals
implicit none

! Input parameters, see default-prm.py for documentation
integer, dimension(3) :: np3, nn, bc1, bc2, n1expand, n2expand
integer :: nt, itstats, itio, itcheck, itstop, npml, ppml, oplevel, mpin, &
    mpout, debug, faultopening, irup, faultnormal, nsource
real :: tm0, dt, dx(3), rho1, rho2, vp1, vp2, vs1, vs2, gam1, gam2, hourglass(2), &
    vdamp, rexpand, affine(9), gridnoise, ihypo(3), vpml, slipvector(3)
real :: period, source1(3), source2(3), vrup, rcrit, trelax, svtol, rnucl, tmnucl, delts, tv 
character(16) :: source, timefunction, eplasticity, friction, pcdep, ivols

! Miscellaneous parameters
real, parameter :: pi = 3.14159265
real :: &
    mptimer,        & ! MPI timing
    iotimer,        & ! I/O timing
    tm                ! time
integer :: &
    it,             & ! current time step
    ifn,            & ! fault normal component=abs(faultnormal)
    ip,             & ! process rank
    ipid,           & ! processor ID
    np0               ! number of processes available
integer, dimension(3) :: &
    nl3,            & ! number of mesh nodes per process
    nm,             & ! size of local 3D arrays
    nhalo,          & ! number of ghost nodes
    ip3,            & ! 3D process rank
    ip3root,        & ! 3D root process rank
    ip2root,        & ! 2D root process rank
    i1bc, i2bc,     & ! model boundary
    i1pml, i2pml,   & ! PML boundary
    i1core, i2core, & ! core region
    i1node, i2node, & ! node region
    i1cell, i2cell, & ! cell region
    nnoff             ! offset between local and global indices
logical :: &
    sync,           & ! synchronize processes
    verb,           & ! print messages
    master            ! master process flag
character(256) :: &
    str               ! string for storing file names

! 1D dynamic arrays
real, allocatable, dimension(:) :: &
    dx1, dx2, dx3,  & ! x, y, z rectangular element size
    dn1,            & ! pml node damping -2*d     / (2+d*dt)
    dn2,            & ! pml node damping  2       / (2+d*dt)
    dc1,            & ! pml cell damping (2-d*dt) / (2+d*dt)
    dc2               ! pml cell damping  2*dt    / (2+d*dt)

! PML state
real, allocatable, dimension(:,:,:,:) :: &
    n1, n2, n3,     & ! surface normal near boundary
    n4, n5, n6,     & ! surface normal far boundary
    p1, p2, p3,     & ! pml momentum near side
    p4, p5, p6,     & ! pml momentum far side
    g1, g2, g3,     & ! pml gradient near side
    g4, g5, g6        ! pml gradient far side

! B matrix
real, allocatable, dimension(:,:,:,:,:) :: bb

! Volume fields
real, allocatable, target, dimension(:,:,:) :: &
    vc,             & ! cell volume
    mr,             & ! mass ratio
    lam, mu,        & ! Lame parameters
    gam,            & ! viscosity
!    qp, qs,         & ! anelastic coefficients
    yy,             & ! hourglass constant
    s1, s2,         &  ! temporary storage
    mco,            & 
    phi,            &
    epm,            &
    mur,            &
    r1, r2, r3,     &
    r4, r5

real, allocatable, target, dimension(:,:,:,:) :: &
    xx,             & ! node locations
    vv,             & ! velocity
    uu,             & ! displacement
    w1, w2,         &
    dep1, dep2,     &
    ep1, ep2,       &
    z1, z2,         &
    si1, si2         


! Fault surface fields
real, allocatable, target, dimension(:,:,:) :: &
    co,             & ! cohesion
    area,           & ! fault element area
    rhypo,          & ! radius to hypocenter
    lamf, muf,      & ! moduli at the fault nodes
    sl,             & ! slip path length
    psv,            & ! peak slip velocity
    trup,           & ! rupture time
    tarr,           & ! arrest time
    tn, ts,         &
    tnpc, tnold,    &
    mus, mud,       &
    dc,             &
    af, bf, v0, f0, &
    ll, fw, vw,     &
    psi,            &
    lpc,            &
    svtrl, svold,   &
    sv0,            &
    f1, f2, f3,     &
    f4, f5,         &
    fun, dfun, delf    

real, allocatable, target, dimension(:,:,:,:) :: &
    nhat,           & ! fault surface normals
    t0, ts0,        & 
    tp,             &
    t1, t2, t3       
end module

! Difference operator, cell to node
module m_diffcn
implicit none
contains

subroutine diffcn( df, f, i, a, i1, i2, oplevel, bb, x, dx1, dx2, dx3, dx )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:), bb(:,:,:,:,:), x(:,:,:,:), &
    dx1(:), dx2(:), dx3(:), dx(3)
integer, intent(in) :: i, a, i1(3), i2(3), oplevel
real :: h
integer :: j, k, l, b, c

if ( any( i1 > i2 ) ) return

select case( oplevel )

! Saved B matrix, flops: 8* 7+
case( 6 )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    df(j,k,l) = &
    - bb(j,k,l,5,a) * f(j,k,l,i) - f(j-1,k-1,l-1,i) * bb(j-1,k-1,l-1,1,a) &
    - bb(j,k-1,l-1,6,a) * f(j,k-1,l-1,i) - f(j-1,k,l,i) * bb(j-1,k,l,2,a) &
    - bb(j-1,k,l-1,7,a) * f(j-1,k,l-1,i) - f(j,k-1,l,i) * bb(j,k-1,l,3,a) &
    - bb(j-1,k-1,l,8,a) * f(j-1,k-1,l,i) - f(j,k,l-1,i) * bb(j,k,l-1,4,a)
end do
end do
end do

! Constant grid, flops: 1* 7+
case( 1 )
select case( a )
case( 1 )
    h = sign( 0.25 * dx(2) * dx(3), dx(1) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        + f(j,k-1,l-1,i) - f(j-1,k,l,i) &
        - f(j-1,k,l-1,i) + f(j,k-1,l,i) &
        - f(j-1,k-1,l,i) + f(j,k,l-1,i) )
    end do
    end do
    end do
case( 2 )
    h = sign( 0.25 * dx(3) * dx(1), dx(2) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        - f(j,k-1,l-1,i) + f(j-1,k,l,i) &
        + f(j-1,k,l-1,i) - f(j,k-1,l,i) &
        - f(j-1,k-1,l,i) + f(j,k,l-1,i) )
    end do
    end do
    end do
case( 3 )
    h = sign( 0.25 * dx(1) * dx(2), dx(3) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        - f(j,k-1,l-1,i) + f(j-1,k,l,i) &
        - f(j-1,k,l-1,i) + f(j,k-1,l,i) &
        + f(j-1,k-1,l,i) - f(j,k,l-1,i) )
    end do
    end do
    end do
end select

! Rectangular grid, flops: 6* 7+
case( 2 )
h = sign( 0.25, product( dx ) )
select case( a )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx3(l)   * ( dx2(k) * ( f(j,k,l,i)   - f(j-1,k,l,i) )   + dx2(k-1) * ( f(j,k-1,l,i)   - f(j-1,k-1,l,i)   ) ) + &
    dx3(l-1) * ( dx2(k) * ( f(j,k,l-1,i) - f(j-1,k,l-1,i) ) + dx2(k-1) * ( f(j,k-1,l-1,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx1(j)   * ( dx3(l) * ( f(j,k,l,i)   - f(j,k-1,l,i) )   + dx3(l-1) * ( f(j,k,l-1,i)   - f(j,k-1,l-1,i)   ) ) + &
    dx1(j-1) * ( dx3(l) * ( f(j-1,k,l,i) - f(j-1,k-1,l,i) ) + dx3(l-1) * ( f(j-1,k,l-1,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx2(k)   * ( dx1(j) * ( f(j,k,l,i)   - f(j,k,l-1,i) )   + dx1(j-1) * ( f(j-1,k,l,i)   - f(j-1,k,l-1,i)   ) ) + &
    dx2(k-1) * ( dx1(j) * ( f(j,k-1,l,i) - f(j,k-1,l-1,i) ) + dx1(j-1) * ( f(j-1,k-1,l,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
end select

! Parallelepiped grid, flops: 33* 47+
case( 3 )
h = sign( 0.25, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    (x(j+1,k,l,b)*(x(j,k+1,l,c)-x(j,k,l+1,c)) &
    +x(j,k+1,l,b)*(x(j,k,l+1,c)-x(j+1,k,l,c)) &
    +x(j,k,l+1,b)*(x(j+1,k,l,c)-x(j,k+1,l,c))) &
+f(j,k-1,l-1,i)* &
    (x(j+1,k,l,b)*(x(j,k-1,l,c)-x(j,k,l-1,c)) &
    +x(j,k-1,l,b)*(x(j,k,l-1,c)-x(j+1,k,l,c)) &
    +x(j,k,l-1,b)*(x(j+1,k,l,c)-x(j,k-1,l,c))) &
+f(j-1,k,l-1,i)* &
    (x(j,k+1,l,b)*(x(j,k,l-1,c)-x(j-1,k,l,c)) &
    +x(j,k,l-1,b)*(x(j-1,k,l,c)-x(j,k+1,l,c)) &
    +x(j-1,k,l,b)*(x(j,k+1,l,c)-x(j,k,l-1,c))) &
+f(j-1,k-1,l,i)* &
    (x(j,k,l+1,b)*(x(j-1,k,l,c)-x(j,k-1,l,c)) &
    +x(j-1,k,l,b)*(x(j,k-1,l,c)-x(j,k,l+1,c)) &
    +x(j,k-1,l,b)*(x(j,k,l+1,c)-x(j-1,k,l,c))) &
+f(j-1,k-1,l-1,i)* &
    (x(j-1,k,l,b)*(x(j,k,l-1,c)-x(j,k-1,l,c)) &
    +x(j,k-1,l,b)*(x(j-1,k,l,c)-x(j,k,l-1,c)) &
    +x(j,k,l-1,b)*(x(j,k-1,l,c)-x(j-1,k,l,c))) &
+f(j-1,k,l,i)* &
    (x(j-1,k,l,b)*(x(j,k,l+1,c)-x(j,k+1,l,c)) &
    +x(j,k+1,l,b)*(x(j-1,k,l,c)-x(j,k,l+1,c)) &
    +x(j,k,l+1,b)*(x(j,k+1,l,c)-x(j-1,k,l,c))) &
+f(j,k-1,l,i)* &
    (x(j,k-1,l,b)*(x(j+1,k,l,c)-x(j,k,l+1,c)) &
    +x(j,k,l+1,b)*(x(j,k-1,l,c)-x(j+1,k,l,c)) &
    +x(j+1,k,l,b)*(x(j,k,l+1,c)-x(j,k-1,l,c))) &
+f(j,k,l-1,i)* &
    (x(j,k,l-1,b)*(x(j,k+1,l,c)-x(j+1,k,l,c)) &
    +x(j+1,k,l,b)*(x(j,k,l-1,c)-x(j,k+1,l,c)) &
    +x(j,k+1,l,b)*(x(j+1,k,l,c)-x(j,k,l-1,c))))
end do
end do
end do

! General grid one-point quadrature, flops: 33* 119+
case( 4 )
h = sign( 0.0625, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c))) &
+f(j,k-1,l-1,i)* &
    ((x(j+1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k-1,l,c)-x(j+1,k,l-1,c)-x(j,k,l-1,c)+x(j+1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j+1,k,l-1,b))*(x(j,k,l-1,c)-x(j+1,k-1,l,c)-x(j+1,k,l,c)+x(j,k-1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j+1,k-1,l,b))*(x(j+1,k,l,c)-x(j,k-1,l-1,c)-x(j,k-1,l,c)+x(j+1,k,l-1,c))) &
+f(j-1,k,l-1,i)* &
    ((x(j,k+1,l,b)-x(j-1,k,l-1,b))*(x(j,k,l-1,c)-x(j-1,k+1,l,c)-x(j-1,k,l,c)+x(j,k+1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j-1,k+1,l,b))*(x(j-1,k,l,c)-x(j,k+1,l-1,c)-x(j,k+1,l,c)+x(j-1,k,l-1,c)) &
    +(x(j-1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k+1,l,c)-x(j-1,k,l-1,c)-x(j,k,l-1,c)+x(j-1,k+1,l,c))) &
+f(j-1,k-1,l,i)* &
    ((x(j,k,l+1,b)-x(j-1,k-1,l,b))*(x(j-1,k,l,c)-x(j,k-1,l+1,c)-x(j,k-1,l,c)+x(j-1,k,l+1,c)) &
    +(x(j-1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k-1,l,c)-x(j-1,k,l+1,c)-x(j,k,l+1,c)+x(j-1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l+1,b))*(x(j,k,l+1,c)-x(j-1,k-1,l,c)-x(j-1,k,l,c)+x(j,k-1,l+1,c))) &
+f(j-1,k-1,l-1,i)* &
    ((x(j-1,k,l,b)-x(j,k-1,l-1,b))*(x(j-1,k,l-1,c)-x(j,k-1,l,c)-x(j-1,k-1,l,c)+x(j,k,l-1,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l-1,b))*(x(j-1,k-1,l,c)-x(j,k,l-1,c)-x(j,k-1,l-1,c)+x(j-1,k,l,c)) &
    +(x(j,k,l-1,b)-x(j-1,k-1,l,b))*(x(j,k-1,l-1,c)-x(j-1,k,l,c)-x(j-1,k,l-1,c)+x(j,k-1,l,c))) &
+f(j-1,k,l,i)* &
    ((x(j-1,k,l,b)-x(j,k+1,l+1,b))*(x(j-1,k,l+1,c)-x(j,k+1,l,c)-x(j-1,k+1,l,c)+x(j,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j-1,k,l+1,b))*(x(j-1,k+1,l,c)-x(j,k,l+1,c)-x(j,k+1,l+1,c)+x(j-1,k,l,c)) &
    +(x(j,k,l+1,b)-x(j-1,k+1,l,b))*(x(j,k+1,l+1,c)-x(j-1,k,l,c)-x(j-1,k,l+1,c)+x(j,k+1,l,c))) &
+f(j,k-1,l,i)* &
    ((x(j,k-1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k-1,l,c)-x(j,k,l+1,c)-x(j,k-1,l+1,c)+x(j+1,k,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k-1,l,b))*(x(j,k-1,l+1,c)-x(j+1,k,l,c)-x(j+1,k,l+1,c)+x(j,k-1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k-1,l+1,b))*(x(j+1,k,l+1,c)-x(j,k-1,l,c)-x(j+1,k-1,l,c)+x(j,k,l+1,c))) &
+f(j,k,l-1,i)* &
    ((x(j,k,l-1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l-1,c)-x(j+1,k,l,c)-x(j+1,k,l-1,c)+x(j,k+1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l-1,b))*(x(j+1,k,l-1,c)-x(j,k+1,l,c)-x(j+1,k+1,l,c)+x(j,k,l-1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l-1,b))*(x(j+1,k+1,l,c)-x(j,k,l-1,c)-x(j,k+1,l-1,c)+x(j+1,k,l,c))))
end do
end do
end do

! General grid exact, flops: 57* 119+
case( 5 )
h = sign( 1.0 / 12.0, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j,k,l+1,c))+x(j+1,k,l,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k,l,c))+x(j,k+1,l,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l,c))+x(j,k,l+1,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c))) &
+f(j,k-1,l-1,i)* &
    ((x(j+1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k-1,l,c)-x(j,k,l-1,c))+x(j+1,k,l,b)*(x(j+1,k-1,l,c)-x(j+1,k,l-1,c)) &
    +(x(j,k-1,l,b)-x(j+1,k,l-1,b))*(x(j,k,l-1,c)-x(j+1,k,l,c))+x(j,k-1,l,b)*(x(j,k-1,l-1,c)-x(j+1,k-1,l,c)) &
    +(x(j,k,l-1,b)-x(j+1,k-1,l,b))*(x(j+1,k,l,c)-x(j,k-1,l,c))+x(j,k,l-1,b)*(x(j+1,k,l-1,c)-x(j,k-1,l-1,c))) &
+f(j-1,k,l-1,i)* &
    ((x(j,k+1,l,b)-x(j-1,k,l-1,b))*(x(j,k,l-1,c)-x(j-1,k,l,c))+x(j,k+1,l,b)*(x(j,k+1,l-1,c)-x(j-1,k+1,l,c)) &
    +(x(j,k,l-1,b)-x(j-1,k+1,l,b))*(x(j-1,k,l,c)-x(j,k+1,l,c))+x(j,k,l-1,b)*(x(j-1,k,l-1,c)-x(j,k+1,l-1,c)) &
    +(x(j-1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k+1,l,c)-x(j,k,l-1,c))+x(j-1,k,l,b)*(x(j-1,k+1,l,c)-x(j-1,k,l-1,c))) &
+f(j-1,k-1,l,i)* &
    ((x(j,k,l+1,b)-x(j-1,k-1,l,b))*(x(j-1,k,l,c)-x(j,k-1,l,c))+x(j,k,l+1,b)*(x(j-1,k,l+1,c)-x(j,k-1,l+1,c)) &
    +(x(j-1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k-1,l,c)-x(j,k,l+1,c))+x(j-1,k,l,b)*(x(j-1,k-1,l,c)-x(j-1,k,l+1,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l+1,b))*(x(j,k,l+1,c)-x(j-1,k,l,c))+x(j,k-1,l,b)*(x(j,k-1,l+1,c)-x(j-1,k-1,l,c))) &
+f(j-1,k-1,l-1,i)* &
    ((x(j-1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k,l-1,c)-x(j,k-1,l,c))+x(j-1,k,l,b)*(x(j-1,k,l-1,c)-x(j-1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l-1,b))*(x(j-1,k,l,c)-x(j,k,l-1,c))+x(j,k-1,l,b)*(x(j-1,k-1,l,c)-x(j,k-1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j-1,k-1,l,b))*(x(j,k-1,l,c)-x(j-1,k,l,c))+x(j,k,l-1,b)*(x(j,k-1,l-1,c)-x(j-1,k,l-1,c))) &
+f(j-1,k,l,i)* &
    ((x(j-1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l+1,c)-x(j,k+1,l,c))+x(j-1,k,l,b)*(x(j-1,k,l+1,c)-x(j-1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j-1,k,l+1,b))*(x(j-1,k,l,c)-x(j,k,l+1,c))+x(j,k+1,l,b)*(x(j-1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j-1,k+1,l,b))*(x(j,k+1,l,c)-x(j-1,k,l,c))+x(j,k,l+1,b)*(x(j,k+1,l+1,c)-x(j-1,k,l+1,c))) &
+f(j,k-1,l,i)* &
    ((x(j,k-1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k,l,c)-x(j,k,l+1,c))+x(j,k-1,l,b)*(x(j+1,k-1,l,c)-x(j,k-1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k-1,l,b))*(x(j,k-1,l,c)-x(j+1,k,l,c))+x(j,k,l+1,b)*(x(j,k-1,l+1,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k,l+1,c)-x(j,k-1,l,c))+x(j+1,k,l,b)*(x(j+1,k,l+1,c)-x(j+1,k-1,l,c))) &
+f(j,k,l-1,i)* &
    ((x(j,k,l-1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l,c)-x(j+1,k,l,c))+x(j,k,l-1,b)*(x(j,k+1,l-1,c)-x(j+1,k,l-1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k,l-1,c)-x(j,k+1,l,c))+x(j+1,k,l,b)*(x(j+1,k,l-1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l-1,b))*(x(j+1,k,l,c)-x(j,k,l-1,c))+x(j,k+1,l,b)*(x(j+1,k+1,l,c)-x(j,k+1,l-1,c))))
end do
end do
end do

case default; stop 'illegal operator'

end select

end subroutine

end module

! Difference operator, node to cell
module m_diffnc
implicit none
contains

subroutine diffnc( df, f, i, a, i1, i2, oplevel, bb, x, dx1, dx2, dx3, dx )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:), bb(:,:,:,:,:), x(:,:,:,:), &
    dx1(:), dx2(:), dx3(:), dx(3)
integer, intent(in) :: i, a, i1(3), i2(3), oplevel
real :: h
integer :: j, k, l, b, c

if ( any( i1 > i2 ) ) return

select case( oplevel )

! Saved B matrix, flops: 8* 7+
case( 6 )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    df(j,k,l) = &
      bb(j,k,l,1,a) * f(j+1,k+1,l+1,i) + f(j,k,l,i) * bb(j,k,l,5,a) &
    + bb(j,k,l,2,a) * f(j+1,k,l,i) + f(j,k+1,l+1,i) * bb(j,k,l,6,a) &
    + bb(j,k,l,3,a) * f(j,k+1,l,i) + f(j+1,k,l+1,i) * bb(j,k,l,7,a) &
    + bb(j,k,l,4,a) * f(j,k,l+1,i) + f(j+1,k+1,l,i) * bb(j,k,l,8,a)
end do
end do
end do

! Constant grid, flops: 1* 7+
case( 1 )
select case( a )
case( 1 )
    h = sign( 0.25 * dx(2) * dx(3), dx(1) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        + f(j+1,k,l,i) - f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 2 )
    h = sign( 0.25 * dx(3) * dx(1), dx(2) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        + f(j,k+1,l,i) - f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 3 )
    h = sign( 0.25 * dx(1) * dx(2), dx(3) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        + f(j,k,l+1,i) - f(j+1,k+1,l,i) )
    end do
    end do
    end do
end select
  
! Rectangular grid, flops: 2* 7+
case( 2 )
h = sign( 0.25, product( dx ) )
select case( a )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx2(k) * dx3(l) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        + f(j+1,k,l,i) - f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx3(l) * dx1(j) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        + f(j,k+1,l,i) - f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx1(j) * dx2(k) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        + f(j,k,l+1,i) - f(j+1,k+1,l,i) )
    end do
    end do
    end do
end select

! Parallelepiped grid, flops: 17* 27+
case( 3 )
h = sign( 0.25, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
((f(j+1,k+1,l+1,i)-f(j,k,l,i))* &
    (x(j,k+1,l+1,b)*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k,l+1,b)*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +x(j+1,k+1,l,b)*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))) &
+(f(j+1,k,l,i)-f(j,k+1,l+1,i))* &
    (x(j,k,l,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +x(j+1,k,l+1,b)*(x(j,k,l,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k+1,l,b)*(x(j+1,k,l+1,c)-x(j,k,l,c))) &
+(f(j,k+1,l,i)-f(j+1,k,l+1,i))* &
    (x(j,k,l,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k+1,l,b)*(x(j,k,l,c)-x(j,k+1,l+1,c)) &
    +x(j,k+1,l+1,b)*(x(j+1,k+1,l,c)-x(j,k,l,c))) &
+(f(j,k,l+1,i)-f(j+1,k+1,l,i))* &
    (x(j,k,l,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c)) &
    +x(j,k+1,l+1,b)*(x(j,k,l,c)-x(j+1,k,l+1,c)) &
    +x(j+1,k,l+1,b)*(x(j,k+1,l+1,c)-x(j,k,l,c))))
end do
end do
end do

! General grid one-point quadrature, flops: 17* 63+
case( 4 )
h = sign( 0.0625, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
((f(j+1,k+1,l+1,i)-f(j,k,l,i))* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c))) &
+(f(j+1,k,l,i)-f(j,k+1,l+1,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))) &
+(f(j,k+1,l,i)-f(j+1,k,l+1,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))) &
+(f(j,k,l+1,i)-f(j+1,k+1,l,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))))
end do
end do
end do

! General grid exact, flops: 57* 119+
case( 5 )
h = sign( 1.0 / 12.0, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j+1,k+1,l+1,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c))+x(j,k+1,l+1,b)*(x(j,k,l+1,c)-x(j,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c))+x(j+1,k,l+1,b)*(x(j+1,k,l,c)-x(j,k,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c))+x(j+1,k+1,l,b)*(x(j,k+1,l,c)-x(j+1,k,l,c))) &
+f(j+1,k,l,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c))+x(j,k,l,b)*(x(j,k+1,l,c)-x(j,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k+1,l,c)-x(j,k,l,c))+x(j+1,k,l+1,b)*(x(j,k,l+1,c)-x(j+1,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k,l,c)-x(j+1,k,l+1,c))+x(j+1,k+1,l,b)*(x(j+1,k+1,l+1,c)-x(j,k+1,l,c))) &
+f(j,k+1,l,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c))+x(j,k,l,b)*(x(j,k,l+1,c)-x(j+1,k,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l,c)-x(j+1,k+1,l,c))+x(j,k+1,l+1,b)*(x(j+1,k+1,l+1,c)-x(j,k,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l+1,c)-x(j,k,l,c))+x(j+1,k+1,l,b)*(x(j+1,k,l,c)-x(j+1,k+1,l+1,c))) &
+f(j,k,l+1,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))+x(j,k,l,b)*(x(j+1,k,l,c)-x(j,k+1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k,l+1,c)-x(j,k,l,c))+x(j,k+1,l+1,b)*(x(j,k+1,l,c)-x(j+1,k+1,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l,c)-x(j,k+1,l+1,c))+x(j+1,k,l+1,b)*(x(j+1,k+1,l+1,c)-x(j+1,k,l,c))) &
+f(j,k,l,i)* &
    ((x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j,k+1,l,c)-x(j,k,l+1,c))+x(j+1,k,l,b)*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j,k,l+1,c)-x(j+1,k,l,c))+x(j,k+1,l,b)*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j+1,k,l,c)-x(j,k+1,l,c))+x(j,k,l+1,b)*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))) &
+f(j,k+1,l+1,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j,k,l+1,c)-x(j,k+1,l,c))+x(j+1,k+1,l+1,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j+1,k+1,l+1,c)-x(j,k,l+1,c))+x(j,k+1,l,b)*(x(j,k,l,c)-x(j+1,k+1,l,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j,k+1,l,c)-x(j+1,k+1,l+1,c))+x(j,k,l+1,b)*(x(j+1,k,l+1,c)-x(j,k,l,c))) &
+f(j+1,k,l+1,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j+1,k,l,c)-x(j,k,l+1,c))+x(j+1,k+1,l+1,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j,k,l+1,c)-x(j+1,k+1,l+1,c))+x(j+1,k,l,b)*(x(j+1,k+1,l,c)-x(j,k,l,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j+1,k+1,l+1,c)-x(j+1,k,l,c))+x(j,k,l+1,b)*(x(j,k,l,c)-x(j,k+1,l+1,c))) &
+f(j+1,k+1,l,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l,c))+x(j+1,k+1,l+1,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c)) &
    +(x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j+1,k+1,l+1,c)-x(j,k+1,l,c))+x(j+1,k,l,b)*(x(j,k,l,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j+1,k,l,c)-x(j+1,k+1,l+1,c))+x(j,k+1,l,b)*(x(j,k+1,l+1,c)-x(j,k,l,c))))
end do
end do
end do

case default; stop 'illegal operator'

end select

end subroutine

end module

! Hourglass corrections
module m_hourglass
implicit none
contains

! Node to cell
subroutine hourglassnc( df, f, iq, i, i1, i2 )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:)
integer, intent(in) :: iq, i, i1(3), i2(3)
integer :: j, k, l

if ( any( i1 > i2 ) ) return

select case( iq )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        + f(j,k+1,l+1,i) + f(j+1,k,l,i) &
        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        - f(j+1,k+1,l,i) - f(j,k,l+1,i)
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        + f(j+1,k,l+1,i) + f(j,k+1,l,i) &
        - f(j+1,k+1,l,i) - f(j,k,l+1,i)
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        + f(j+1,k+1,l,i) + f(j,k,l+1,i)
    end do
    end do
    end do
case( 4 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) - f(j+1,k+1,l+1,i) &
        + f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        + f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        + f(j+1,k+1,l,i) - f(j,k,l+1,i) 
    end do
    end do
    end do
end select

end subroutine

!------------------------------------------------------------------------------!

! Cell to node
subroutine hourglasscn( df, f, iq, i1, i2 )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:)
integer, intent(in) :: iq, i1(3), i2(3)
integer :: j, k, l

if ( any( i1 > i2 ) ) return

select case( iq )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        + f(j,k-1,l-1) + f(j-1,k,l) &
        - f(j-1,k,l-1) - f(j,k-1,l) &
        - f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        - f(j,k-1,l-1) - f(j-1,k,l) &
        + f(j-1,k,l-1) + f(j,k-1,l) &
        - f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        - f(j,k-1,l-1) - f(j-1,k,l) &
        - f(j-1,k,l-1) - f(j,k-1,l) &
        + f(j-1,k-1,l) + f(j,k,l-1)
    end do
    end do
    end do
case( 4 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) - f(j-1,k-1,l-1) &
        + f(j,k-1,l-1) - f(j-1,k,l) &
        + f(j-1,k,l-1) - f(j,k-1,l) &
        + f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
end select

end subroutine

end module

! Boundary conditions
module m_bc
implicit none
contains

! Scalar field
subroutine scalar_bc( f, bc1, bc2, i1, i2 )
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: bc1(3), bc2(3), i1(3), i2(3)
integer :: b1(3), b2(3), nm(3), j1, k1, l1, j2, k2, l2
nm = (/ size(f,1), size(f,2), size(f,3) /)
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
b1 = abs( mod( bc1, 10 ) )
b2 = abs( mod( bc2, 10 ) )
where ( b1 == 4 ) b1 = 2
where ( b2 == 4 ) b2 = 2
where ( nm == 1 .or. i1 <  1 .or. i1 >= nm ) b1 = 99
where ( nm == 1 .or. i2 <= 1 .or. i2 >  nm ) b2 = 99
if ( b1(1) == 2 ) f(j1,:,:) = f(j1+1,:,:)
if ( b1(2) == 2 ) f(:,k1,:) = f(:,k1+1,:)
if ( b1(3) == 2 ) f(:,:,l1) = f(:,:,l1+1)
if ( b2(1) == 2 ) f(j2,:,:) = f(j2-1,:,:)
if ( b2(2) == 2 ) f(:,k2,:) = f(:,k2-1,:)
if ( b2(3) == 2 ) f(:,:,l2) = f(:,:,l2-1)
end subroutine

! Vector field
subroutine vector_bc( f, bc1, bc2, i1, i2 )
implicit none
real, intent(inout) :: f(:,:,:,:)
integer, intent(in) :: bc1(3), bc2(3), i1(3), i2(3)
integer :: nm(3), b1(3), b2(3), s1(3), s2(3), j1, k1, l1, j2, k2, l2
nm = (/ size(f,1), size(f,2), size(f,3) /)
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
b1 = mod( bc1, 10 )
b2 = mod( bc2, 10 )
where ( nm == 1 .or. i1 < 1 .or. i1 > nm ) b1 = 99
where ( nm == 1 .or. i2 < 1 .or. i2 > nm ) b2 = 99

! Anti-mirror symmetry at the node
if ( b1(1) == -1 ) then; f(j1,:,:,2) = 0.0; f(j1,:,:,3) = 0.0; end if
if ( b1(2) == -1 ) then; f(:,k1,:,3) = 0.0; f(:,k1,:,1) = 0.0; end if
if ( b1(3) == -1 ) then; f(:,:,l1,1) = 0.0; f(:,:,l1,2) = 0.0; end if
if ( b2(1) == -1 ) then; f(j2,:,:,2) = 0.0; f(j2,:,:,3) = 0.0; end if
if ( b2(2) == -1 ) then; f(:,k2,:,3) = 0.0; f(:,k2,:,1) = 0.0; end if
if ( b2(3) == -1 ) then; f(:,:,l2,1) = 0.0; f(:,:,l2,2) = 0.0; end if

! Mirror symmetry at the node
if ( b1(1) == 1 ) f(j1,:,:,1) = 0.0
if ( b1(2) == 1 ) f(:,k1,:,2) = 0.0
if ( b1(3) == 1 ) f(:,:,l1,3) = 0.0
if ( b2(1) == 1 ) f(j2,:,:,1) = 0.0
if ( b2(2) == 1 ) f(:,k2,:,2) = 0.0
if ( b2(3) == 1 ) f(:,:,l2,3) = 0.0

! Rigid
if ( b1(1) == 3 ) f(j1,:,:,:) = 0.0
if ( b1(2) == 3 ) f(:,k1,:,:) = 0.0
if ( b1(3) == 3 ) f(:,:,l1,:) = 0.0
if ( b2(1) == 3 ) f(j2,:,:,:) = 0.0
if ( b2(2) == 3 ) f(:,k2,:,:) = 0.0
if ( b2(3) == 3 ) f(:,:,l2,:) = 0.0

where ( i1 >= nm ) b1 = 99
where ( i2 <= 1  ) b2 = 99

! Continue
if ( b1(1) == 4 ) f(j1,:,:,:) = f(j1+1,:,:,:)
if ( b1(2) == 4 ) f(:,k1,:,:) = f(:,k1+1,:,:)
if ( b1(3) == 4 ) f(:,:,l1,:) = f(:,:,l1+1,:)
if ( b2(1) == 4 ) f(j2,:,:,:) = f(j2-1,:,:,:)
if ( b2(2) == 4 ) f(:,k2,:,:) = f(:,k2-1,:,:)
if ( b2(3) == 4 ) f(:,:,l2,:) = f(:,:,l2-1,:)

! Symmetry at the cell
b1 = abs( b1 )
b2 = abs( b2 )
s1 = sign( 1, bc1 )
s2 = sign( 1, bc2 )
if ( b1(1) == 2 ) then
    f(j1,:,:,1) = -s1(1) * f(j1+1,:,:,1)
    f(j1,:,:,2) =  s1(1) * f(j1+1,:,:,2)
    f(j1,:,:,3) =  s1(1) * f(j1+1,:,:,3)
end if
if ( b1(2) == 2 ) then
    f(:,k1,:,1) =  s1(2) * f(:,k1+1,:,1)
    f(:,k1,:,2) = -s1(2) * f(:,k1+1,:,2)
    f(:,k1,:,3) =  s1(2) * f(:,k1+1,:,3)
end if 
if ( b1(3) == 2 ) then
    f(:,:,l1,1) =  s1(3) * f(:,:,l1+1,1)
    f(:,:,l1,2) =  s1(3) * f(:,:,l1+1,2)
    f(:,:,l1,3) = -s1(3) * f(:,:,l1+1,3)
end if
if ( b2(1) == 2 ) then
    f(j2,:,:,1) = -s2(1) * f(j2-1,:,:,1)
    f(j2,:,:,2) =  s2(1) * f(j2-1,:,:,2)
    f(j2,:,:,3) =  s2(1) * f(j2-1,:,:,3)
end if
if ( b2(2) == 2 ) then 
    f(:,k2,:,1) =  s2(2) * f(:,k2-1,:,1)
    f(:,k2,:,2) = -s2(2) * f(:,k2-1,:,2)
    f(:,k2,:,3) =  s2(2) * f(:,k2-1,:,3)
end if
if ( b2(3) == 2 ) then
    f(:,:,l2,1) =  s2(3) * f(:,:,l2-1,1)
    f(:,:,l2,2) =  s2(3) * f(:,:,l2-1,2)
    f(:,:,l2,3) = -s2(3) * f(:,:,l2-1,3)
end if

end subroutine

end module

! Find surface normals
module m_surfnormals
implicit none
contains

subroutine cellnormals( nhat, x, dx, i1, i2, ihat )
real, intent(out) :: nhat(:,:,:,:)
real, intent(in) :: x(:,:,:,:), dx(3)
integer, intent(in) :: i1(3), i2(3), ihat
integer :: j, k, l, a, b, c
real :: h

nhat = 0.0
h = sign( 0.5, product( dx ) )

do a = 1, 3
    b = modulo( a,   3 ) + 1
    c = modulo( a+1, 3 ) + 1
    select case( ihat )
    case( 1 )
        j = i1(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            nhat(1,k,l,a) = h * &
            ( (x(j,k+1,l,b) - x(j,k,l+1,b)) * (x(j,k+1,l+1,c) - x(j,k,l,c)) &
            - (x(j,k+1,l,c) + x(j,k,l+1,c)) * (x(j,k+1,l+1,b) - x(j,k,l,b)) )
        end do
        end do
    case( 2 )
        k = i1(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            nhat(j,1,l,a) = h * &
            ( (x(j,k,l+1,b) - x(j+1,k,l,b)) * (x(j+1,k,l+1,c) - x(j,k,l,c)) &
            - (x(j,k,l+1,c) + x(j+1,k,l,c)) * (x(j+1,k,l+1,b) - x(j,k,l,b)) )
        end do
        end do
    case( 3 )
        l = i1(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            nhat(j,k,1,a) = h * &
            ( (x(j+1,k,l,b) - x(j,k+1,l,b)) * (x(j+1,k+1,l,c) - x(j,k,l,c)) &
            - (x(j+1,k,l,c) + x(j,k+1,l,c)) * (x(j+1,k+1,l,b) - x(j,k,l,b)) )
        end do
        end do
    case default; stop 'error: surfnormal'
    end select
end do

end subroutine


subroutine nodenormals( nhat, x, dx, i1, i2, ihat )
real, intent(out) :: nhat(:,:,:,:)
real, intent(in) :: x(:,:,:,:), dx(3)
integer, intent(in) :: i1(3), i2(3), ihat
integer :: j, k, l, a, b, c
real :: h

nhat = 0.0
h = sign( 1.0 / 12.0, product( dx ) )

do a = 1, 3
    b = modulo( a,   3 ) + 1
    c = modulo( a+1, 3 ) + 1
    select case( ihat )
    case( 1 )
        j = i1(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            nhat(1,k,l,a) = h * &
            ( x(j,k+1,l,b) * ( x(j,k,l+1,c) + x(j,k+1,l+1,c)   &
                             - x(j,k,l-1,c) - x(j,k+1,l-1,c) ) &
            + x(j,k-1,l,b) * ( x(j,k,l-1,c) + x(j,k-1,l-1,c)   &
                             - x(j,k,l+1,c) - x(j,k-1,l+1,c) ) &
            + x(j,k,l+1,b) * ( x(j,k-1,l,c) + x(j,k-1,l+1,c)   &
                             - x(j,k+1,l,c) - x(j,k+1,l+1,c) ) &
            + x(j,k,l-1,b) * ( x(j,k+1,l,c) + x(j,k+1,l-1,c)   &
                             - x(j,k-1,l,c) - x(j,k-1,l-1,c) ) &
            + x(j,k+1,l+1,b) * ( x(j,k,l+1,c) - x(j,k+1,l,c) ) &
            + x(j,k-1,l-1,b) * ( x(j,k,l-1,c) - x(j,k-1,l,c) ) &
            + x(j,k-1,l+1,b) * ( x(j,k-1,l,c) - x(j,k,l+1,c) ) &
            + x(j,k+1,l-1,b) * ( x(j,k+1,l,c) - x(j,k,l-1,c) ) )
        end do
        end do
    case( 2 )
        k = i1(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            nhat(j,1,l,a) = h * &
            ( x(j,k,l+1,b) * ( x(j+1,k,l,c) + x(j+1,k,l+1,c)   &
                             - x(j-1,k,l,c) - x(j-1,k,l+1,c) ) &
            + x(j,k,l-1,b) * ( x(j-1,k,l,c) + x(j-1,k,l-1,c)   &
                             - x(j+1,k,l,c) - x(j+1,k,l-1,c) ) &
            + x(j+1,k,l,b) * ( x(j,k,l-1,c) + x(j+1,k,l-1,c)   &
                             - x(j,k,l+1,c) - x(j+1,k,l+1,c) ) &
            + x(j-1,k,l,b) * ( x(j,k,l+1,c) + x(j-1,k,l+1,c)   &
                             - x(j,k,l-1,c) - x(j-1,k,l-1,c) ) &
            + x(j+1,k,l+1,b) * ( x(j+1,k,l,c) - x(j,k,l+1,c) ) &
            + x(j-1,k,l-1,b) * ( x(j-1,k,l,c) - x(j,k,l-1,c) ) &
            + x(j+1,k,l-1,b) * ( x(j,k,l-1,c) - x(j+1,k,l,c) ) &
            + x(j-1,k,l+1,b) * ( x(j,k,l+1,c) - x(j-1,k,l,c) ) )
        end do
        end do
    case( 3 )
        l = i1(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            nhat(j,k,1,a) = h * &
            ( x(j+1,k,l,b) * ( x(j,k+1,l,c) + x(j+1,k+1,l,c)   &
                             - x(j,k-1,l,c) - x(j+1,k-1,l,c) ) &
            + x(j-1,k,l,b) * ( x(j,k-1,l,c) + x(j-1,k-1,l,c)   &
                             - x(j,k+1,l,c) - x(j-1,k+1,l,c) ) &
            + x(j,k+1,l,b) * ( x(j-1,k,l,c) + x(j-1,k+1,l,c)   &
                             - x(j+1,k,l,c) - x(j+1,k+1,l,c) ) &
            + x(j,k-1,l,b) * ( x(j+1,k,l,c) + x(j+1,k-1,l,c)   &
                             - x(j-1,k,l,c) - x(j-1,k-1,l,c) ) &
            + x(j+1,k+1,l,b) * ( x(j,k+1,l,c) - x(j+1,k,l,c) ) &
            + x(j-1,k-1,l,b) * ( x(j,k-1,l,c) - x(j-1,k,l,c) ) &
            + x(j-1,k+1,l,b) * ( x(j-1,k,l,c) - x(j,k+1,l,c) ) &
            + x(j+1,k-1,l,b) * ( x(j+1,k,l,c) - x(j,k-1,l,c) ) )
        end do
        end do
    case default; stop 'error: surfnormal'
    end select
end do

end subroutine

end module

! Miscellaneous utilities
module m_util
implicit none
contains

! Array reciprocal
subroutine invert( f )
real, intent(inout) :: f(:,:,:)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
do l = 1, n(3)
do k = 1, n(2)
do j = 1, n(1)
    if ( f(j,k,l) /= 0.0 ) f(j,k,l) = 1.0 / f(j,k,l)
end do
end do
end do
end subroutine

! Squared distance to x0
subroutine radius( r, x, x0, i1, i2 )
real, intent(out) :: r(:,:,:)
real, intent(in) :: x(:,:,:,:), x0(3)
integer, intent(in) :: i1(3), i2(3)
integer :: n(3), j, k, l
n = (/ size(r,1), size(r,2), size(r,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in radius'
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    r(j,k,l) = &
    ( x(j,k,l,1) - x0(1) ) * ( x(j,k,l,1) - x0(1) ) + &
    ( x(j,k,l,2) - x0(2) ) * ( x(j,k,l,2) - x0(2) ) + &
    ( x(j,k,l,3) - x0(3) ) * ( x(j,k,l,3) - x0(3) )
end do
end do
end do
end subroutine

! Average of local eight values
subroutine average( f2, f1, i1, i2, d )
real, intent(out) :: f2(:,:,:)
real, intent(in) :: f1(:,:,:)
integer, intent(in) :: i1(3), i2(3), d
integer :: n(3), j, k, l
n = (/ size(f1,1), size(f1,2), size(f1,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in average'
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    f2(j,k,l) = 0.125 * &
    ( f1(j,k,l) + f1(j+d,k+d,l+d) &
    + f1(j,k+d,l+d) + f1(j+d,k,l) &
    + f1(j+d,k,l+d) + f1(j,k+d,l) &
    + f1(j+d,k+d,l) + f1(j,k,l+d) )
end do
end do
end do
call set_halo( f2, 0.0, i1, i2 )
end subroutine

! Set array to real value outside specified region
subroutine set_halo( f, r, i1, i2 )
real, intent(inout) :: f(:,:,:)
real, intent(in) :: r
integer, intent(in) :: i1(3), i2(3)
integer :: n(3), i3(3), i4(3)
n = (/ size(f,1), size(f,2), size(f,3) /)
i3 = min( i1, n + 1 )
i4 = max( i2, 0 )
if ( n(1) > 1 ) f(:i3(1)-1,:,:) = r
if ( n(2) > 1 ) f(:,:i3(2)-1,:) = r
if ( n(3) > 1 ) f(:,:,:i3(3)-1) = r
if ( n(1) > 1 ) f(i4(1)+1:,:,:) = r
if ( n(2) > 1 ) f(:,i4(2)+1:,:) = r
if ( n(3) > 1 ) f(:,:,i4(3)+1:) = r
end subroutine

! L2 vector norm
subroutine vector_norm( f, w, i1, i2, di )
real, intent(out) :: f(:,:,:)
real, intent(in) :: w(:,:,:,:)
integer, intent(in) :: i1(3), i2(3), di(3)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in vector_norm'
do l = i1(3), i2(3), di(3)
do k = i1(2), i2(2), di(2)
do j = i1(1), i2(1), di(1)
    f(j,k,l) = &
    w(j,k,l,1) * w(j,k,l,1) + &
    w(j,k,l,2) * w(j,k,l,2) + &
    w(j,k,l,3) * w(j,k,l,3)
end do
end do
end do
end subroutine

! Frobenius tensor norm - much faster than L2 norm for tensors
subroutine tensor_norm( f, w1, w2, i1, i2, di )
real, intent(out) :: f(:,:,:)
real, intent(in) :: w1(:,:,:,:), w2(:,:,:,:)
integer, intent(in) :: i1(3), i2(3), di(3)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in tensor_norm'
do l = i1(3), i2(3), di(3)
do k = i1(2), i2(2), di(2)
do j = i1(1), i2(1), di(1)
    f(j,k,l) = &
    w1(j,k,l,1) * w1(j,k,l,1) + &
    w1(j,k,l,2) * w1(j,k,l,2) + &
    w1(j,k,l,3) * w1(j,k,l,3) + &
    ( w2(j,k,l,1) * w2(j,k,l,1) &
    + w2(j,k,l,2) * w2(j,k,l,2) &
    + w2(j,k,l,3) * w2(j,k,l,3) ) * 2.
end do
end do
end do
end subroutine

! In-place linear interpolation 
subroutine interpolate( f, i3, i4, di )
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: i3(3), i4(3), di(3)
integer :: i1(3), i2(3), n(3), i, j, k, l, d
real :: h1, h2
n = (/ size(f,1), size(f,2), size(f,3) /)
i1 = i3
i2 = i4
where( i1 < 1 ) i1 = i1 + (-i1 / di + 1) * di
where( i2 > n ) i2 = i1 + (n - i1) / di * di
d = di(1)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1) - d, d
        f(j+i,k,l) = h1 * f(j,k,l) + h2 * f(j+d,k,l)
    end do
    end do
    end do
end do
d = di(2)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3), di(1)
    do k = i1(2), i2(2) - d, d
    do j = i1(1), i2(1)
        f(j,k+i,l) = h1 * f(j,k,l) + h2 * f(j,k+d,l)
    end do
    end do
    end do
end do
d = di(3)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3) - d, d
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        f(j,k,l+i) = h1 * f(j,k,l) + h2 * f(j,k,l+d)
    end do
    end do
    end do
end do
end subroutine

! Time function
real function time_function( tfunc, tm, dt, period )
character(*), intent(in) :: tfunc
real, intent(in) :: tm, dt, period
real, parameter :: pi = 3.14159265
real :: t
time_function = 0.0
select case( tfunc )
case( 'ramp')
    if ( abs(tm) < period ) then
        time_function = 0.5*(1-cos(pi*tm/period))
    else
        time_function = 1.0
    end if
!    if ( tm < period ) time_function = 0.5*pi/period*sin(pi*tm/period) 
case( 'const'  )
    time_function = 1.0
case( 'delta'  )
    if ( abs( tm ) < 0.25 * dt ) time_function = 1.0
case( 'brune' )
    time_function = -exp( -tm / period ) / period * (tm + period) + 1.0
case( 'dbrune' )
    time_function =  exp( -tm / period ) / period ** 2.0 * tm
case( 'ddbrune' )
    time_function = -exp( -tm / period ) / period ** 3.0 * (tm - period) 
case( 'gaussian' )
    t = ( tm - 4.0 * period ) / period
    time_function = exp( -0.5 * t * t ) / ( period * sqrt( 2.0 * pi ) )
case( 'dgaussian', 'ricker1' )
    t = tm - period
    time_function = t * exp( -2.0 * (pi * t / period) ** 2.0 )
case( 'ddgaussian', 'ricker2' )
    t = ( pi * (tm - period) / period ) ** 2.0
    time_function = (1.0 - 2.0 * t) * exp( -t )
case default
    write( 0, * ) 'invalid time func: ', trim( tfunc )
    stop
end select
end function

! Timer
real function timer( i )
integer, intent(in) :: i
integer, save :: clock0, clockrate, clockmax
integer(8), save :: timers(8)
integer :: clock1
if ( i == 0 ) then
    call system_clock( clock0, clockrate, clockmax )
    timer = 0
    timers = 0
else
    call system_clock( clock1 )
    timers = timers + clock1 - clock0
    if ( clock0 > clock1 ) timers = timers + clockmax
    clock0 = clock1
    timer = real( timers(i) ) / real( clockrate )
    timers(:i) = 0
end if
end function

end module

! Fortran real binary I/O
module m_frio
integer, parameter :: frio_file_null = -1
contains

subroutine frio2( fh, f, mode, filename, m, o, verb )
implicit none
integer, intent(inout) :: fh
real, intent(inout) :: f(:,:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: m, o
logical, intent(in) :: verb
integer, save :: filehandle = 10
integer :: i, n
if ( fh == frio_file_null ) then
    filehandle = filehandle + 1
    fh = filehandle
    if ( verb ) write( 0, * ) 'Opening file: ', trim( filename )
    inquire( iolength=i ) f(:,1)
    if ( mode == 'r' .or. o > 0 ) then
        open( fh, file=filename, recl=i, form='unformatted', access='direct', &
        status='old' )
    else
        open( fh, file=filename, recl=i, form='unformatted', access='direct', &
        status='new' )
    end if
end if
if ( verb ) write( 0, * ) 'Writing file: ', trim( filename )
n = size( f, 2 )
if ( mode == 'r' ) then
    do i = 1, n
        read( fh, rec=o+i ) f(:,i)
    end do
else
    do i = 1, n
        write( fh, rec=o+i ) f(:,i)
    end do
end if
if ( o+n == m ) then
    close( fh )
    if ( fh == filehandle ) filehandle = filehandle - 1
    fh = frio_file_null
end if
end subroutine

end module

! Collective routines - MPI version
module m_collective
use mpi
implicit none
integer, parameter :: file_null = mpi_file_null
integer, private :: np3(3), comm1d(3), comm2d(3), comm3d
contains

! Initialize
subroutine initialize( np0, ip )
use mpi
integer, intent(out) :: np0, ip
integer :: e
call mpi_init( e )
call mpi_comm_size( mpi_comm_world, np0, e  )
call mpi_comm_rank( mpi_comm_world, ip, e  )
end subroutine

! Finalize
subroutine finalize
use mpi
integer :: e
call mpi_finalize( e )
end subroutine

! Process rank
subroutine rank( ip3, ipid, np3in )
use mpi
integer, intent(out) :: ip3(3), ipid
integer, intent(in) :: np3in(3)
integer :: ip, i, e
logical :: hat(3), period(3) = .false.
np3 = np3in
call mpi_cart_create( mpi_comm_world, 3, np3, period, .true., comm3d, e )
if ( comm3d == mpi_comm_null ) then
    call mpi_comm_rank( mpi_comm_world, ip, e  )
    write( 0, * ) ip, ' unused process'
    call mpi_finalize( e )
    stop
end if
call mpi_comm_rank( comm3d, ip, e  )
call mpi_cart_coords( comm3d, ip, 3, ip3, e )
ipid = ip3(1) + np3(1) * ( ip3(2) + np3(2) * ip3(3) )
do i = 1, 3
    hat = .false.
    hat(i) = .true.
    call mpi_cart_sub( comm3d, hat, comm1d(i), e )
    hat = .true.
    hat(i) = .false.
    call mpi_cart_sub( comm3d, hat, comm2d(i), e )
end do
end subroutine

! Find communicator and rank from Cartesian coordinates.
! Exclude dimensions with coordinate < 0.
subroutine commrank( comm, rank, coords )
use mpi
integer, intent(out) :: comm, rank
integer, intent(in) :: coords(3)
integer :: coords1(1), coords2(2), ii(1), i, n, e
n = count( coords >= 0 )
if ( n == 3 ) then
    comm = comm3d
    call mpi_cart_rank( comm, coords, rank, e )
elseif ( n == 2 ) then
    ii = minloc( coords )
    i = ii(1)
    comm = comm2d(i)
    coords2 = (/ coords(:i-1), coords(i+1:) /)
    call mpi_cart_rank( comm, coords2, rank, e )
elseif ( n == 1 ) then
    ii = maxloc( coords )
    i = ii(1)
    comm = comm1d(i)
    coords1 = coords(i:i)
    call mpi_cart_rank( comm, coords1, rank, e )
else
    write ( 0, * ) 'Problem in commrank: ', coords
    stop
end if
end subroutine

! Barrier
subroutine barrier
use mpi
integer :: e
call mpi_barrier( comm3d, e )
end subroutine

! Broadcast real 1d
subroutine rbroadcast1( r, coords )
use mpi
real, intent(inout) :: r(:)
integer, intent(in) :: coords(3)
integer :: comm, root, i, e
i = size(r)
call commrank( comm, root, coords )
call mpi_bcast( r(1), i, mpi_real, root, comm, e )
end subroutine

! Broadcast real 4d
subroutine rbroadcast4( r, coords )
use mpi
real, intent(inout) :: r(:,:,:,:)
integer, intent(in) :: coords(3)
integer :: comm, root, i, e
i = size(r)
call commrank( comm, root, coords )
call mpi_bcast( r(1,1,1,1), i, mpi_real, root, comm, e )
end subroutine

! Reduce integer
subroutine ireduce( ii, i, op, coords )
use mpi
integer, intent(out) :: ii
integer, intent(in) :: i, coords(3)
character(*), intent(in) :: op
integer :: iop, comm, root, e
select case( op )
case( 'min', 'allmin' ); iop = mpi_min
case( 'max', 'allmax' ); iop = mpi_max
case( 'sum', 'allsum' ); iop = mpi_sum
case default
stop 'Problem in ireduce'
end select
call commrank( comm, root, coords )
if ( op(1:3) == 'all' ) then
    call mpi_allreduce( i, ii, 1, mpi_integer, iop, comm, e )
else
    call mpi_reduce( i, ii, 1, mpi_integer, iop, root, comm, e )
end if
end subroutine

! Reduce real 1d
subroutine rreduce1( rr, r, op, coords )
use mpi
real, intent(out) :: rr(:)
real, intent(in) :: r(:)
integer, intent(in) :: coords(3)
character(*), intent(in) :: op
integer :: iop, comm, root, e, i
select case( op )
case( 'min', 'allmin' ); iop = mpi_min
case( 'max', 'allmax' ); iop = mpi_max
case( 'sum', 'allsum' ); iop = mpi_sum
case default
stop 'problem in rreduce1'
end select
call commrank( comm, root, coords )
i = size(r)
if ( op(1:3) == 'all' ) then
    call mpi_allreduce( r(1), rr(1), i, mpi_real, iop, comm, e )
else
    call mpi_reduce( r(1), rr(1), i, mpi_real, iop, root, comm, e )
end if
end subroutine

! Reduce real 2d
subroutine rreduce2( rr, r, op, coords )
use mpi
real, intent(out) :: rr(:,:)
real, intent(in) :: r(:,:)
integer, intent(in) :: coords(3)
character(*), intent(in) :: op
integer :: iop, comm, root, e, i
select case( op )
case( 'min', 'allmin' ); iop = mpi_min
case( 'max', 'allmax' ); iop = mpi_max
case( 'sum', 'allsum' ); iop = mpi_sum
case default
stop 'problem in rreduce2'
end select
call commrank( comm, root, coords )
i = size(r)
if ( op(1:3) == 'all' ) then
    call mpi_allreduce( r(1,1), rr(1,1), i, mpi_real, iop, comm, e )
else
    call mpi_reduce( r(1,1), rr(1,1), i, mpi_real, iop, root, comm, e )
end if
end subroutine

! Scalar swap halo
subroutine scalar_swap_halo( f, nh )
use mpi
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: nh(3)
integer :: i, e, prev, next, nm(3), n(3), isend(3), irecv(3), tsend, trecv, comm
nm = (/ size(f,1), size(f,2), size(f,3) /)
do i = 1, 3
if ( np3(i) > 1 .and. nm(i) > 1 ) then
    comm = comm3d
    call mpi_cart_shift( comm, i-1, 1, prev, next, e )
    n = nm
    n(i) = nh(i)
    isend = 0
    irecv = 0
    isend(i) = nm(i) - 2 * nh(i)
    call mpi_type_create_subarray( 3, nm, n, isend, mpi_order_fortran, mpi_real, tsend, e )
    call mpi_type_create_subarray( 3, nm, n, irecv, mpi_order_fortran, mpi_real, trecv, e )
    call mpi_type_commit( tsend, e )
    call mpi_type_commit( trecv, e )
    call mpi_sendrecv( f(1,1,1), 1, tsend, next, 0, f(1,1,1), 1, trecv, prev, 0, comm, mpi_status_ignore, e )
    call mpi_type_free( tsend, e )
    call mpi_type_free( trecv, e )
    isend(i) = nh(i)
    irecv(i) = nm(i) - nh(i)
    call mpi_type_create_subarray( 3, nm, n, isend, mpi_order_fortran, mpi_real, tsend, e )
    call mpi_type_create_subarray( 3, nm, n, irecv, mpi_order_fortran, mpi_real, trecv, e )
    call mpi_type_commit( tsend, e )
    call mpi_type_commit( trecv, e )
    call mpi_sendrecv( f(1,1,1), 1, tsend, prev, 1, f(1,1,1), 1, trecv, next, 1, comm, mpi_status_ignore, e )
    call mpi_type_free( tsend, e )
    call mpi_type_free( trecv, e )
end if
end do
end subroutine

! Vector swap halo
subroutine vector_swap_halo( f, nh )
use mpi
real, intent(inout) :: f(:,:,:,:)
integer, intent(in) :: nh(3)
integer :: i, e, prev, next, nm(4), n(4), isend(4), irecv(4), tsend, trecv, comm
nm = (/ size(f,1), size(f,2), size(f,3), size(f,4) /)
do i = 1, 3
if ( np3(i) > 1 .and. nm(i) > 1 ) then
    comm = comm3d
    call mpi_cart_shift( comm, i-1, 1, prev, next, e )
    n = nm
    n(i) = nh(i)
    isend = 0
    irecv = 0
    isend(i) = nm(i) - 2 * nh(i)
    call mpi_type_create_subarray( 4, nm, n, isend, mpi_order_fortran, mpi_real, tsend, e )
    call mpi_type_create_subarray( 4, nm, n, irecv, mpi_order_fortran, mpi_real, trecv, e )
    call mpi_type_commit( tsend, e )
    call mpi_type_commit( trecv, e )
    call mpi_sendrecv( f(1,1,1,1), 1, tsend, next, 0, f(1,1,1,1), 1, trecv, prev, 0, comm, mpi_status_ignore, e )
    call mpi_type_free( tsend, e )
    call mpi_type_free( trecv, e )
    isend(i) = nh(i)
    irecv(i) = nm(i) - nh(i)
    call mpi_type_create_subarray( 4, nm, n, isend, mpi_order_fortran, mpi_real, tsend, e )
    call mpi_type_create_subarray( 4, nm, n, irecv, mpi_order_fortran, mpi_real, trecv, e )
    call mpi_type_commit( tsend, e )
    call mpi_type_commit( trecv, e )
    call mpi_sendrecv( f(1,1,1,1), 1, tsend, prev, 1, f(1,1,1,1), 1, trecv, next, 1, comm, mpi_status_ignore, e )
    call mpi_type_free( tsend, e )
    call mpi_type_free( trecv, e )
end if
end do
end subroutine

! 2D input/output
subroutine rio2( fh, f, mode, filename, mm, nn, oo, mpio, verb )
use m_frio
use mpi
integer, intent(inout) :: fh
real, intent(inout) :: f(:,:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(inout) :: mm(:), nn(:), oo(:)
integer, intent(in) :: mpio
logical, intent(in) :: verb
integer :: i, e
integer(kind=mpi_offset_kind) :: offset
i = size( oo )
if ( mpio == 0 ) then
    if ( any( nn <= 0 ) ) return
    call frio2( fh, f, mode, filename, mm(i), oo(i), verb )
    return
end if
if ( fh == mpi_file_null ) then
    call mpopen( fh, mode, filename, mm, nn, oo, verb )
    if ( any( nn <= 0 ) ) return
end if
offset = oo(i)
offset = offset * size( f, 1 )
i = size( f )
if ( mode == 'r' ) then
    if ( mpio > 0 ) then
        call mpi_file_read_at_all( fh, offset, f(1,1), i, mpi_real, mpi_status_ignore, e )
    else
        call mpi_file_read_at( fh, offset, f(1,1), i, mpi_real, mpi_status_ignore, e )
    end if
else
    if ( mpio > 0 ) then
        call mpi_file_write_at_all( fh, offset, f(1,1), i, mpi_real, mpi_status_ignore, e )
    else
        call mpi_file_write_at( fh, offset, f(1,1), i, mpi_real, mpi_status_ignore, e )
    end if
end if
i = size( oo )
if ( oo(i) + nn(i) == mm(i) ) then
    call mpi_file_close( fh, e )
    fh = mpi_file_null
end if
end subroutine

! 1D input/output
subroutine rio1( fh, f, mode, filename, m, o, mpio, verb )
integer, intent(inout) :: fh
real, intent(inout) :: f(:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: m, o, mpio
logical, intent(in) :: verb
integer :: mm(2), nn(2), oo(2)
real :: ff(1,size(f))
if ( mode == 'w' ) ff(1,:) = f
mm = (/ 1, m /)
nn = (/ 1, size(f) /)
oo = (/ 0, o /)
call rio2( fh, ff, mode, filename, mm, nn, oo, mpio, verb )
if ( mode == 'r' ) f = ff(1,:)
end subroutine

! Open file with MPIIO
! does not use mm(4) or nn(4)
subroutine mpopen( fh, mode, filename, mm, nn, oo, verb )
use mpi
integer, intent(out) :: fh
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: mm(:), nn(:), oo(:)
logical, intent(in) :: verb
integer :: mmm(size(mm)), nnn(size(nn)), ooo(size(oo)), ndims, i, n, ip, ftype, comm0, comm, e
integer(kind=mpi_offset_kind) :: offset = 0
n = size( mm )
ndims = count( mm(1:n-1) > 1 )
do i = 1, n-1
    select case( ndims )
    case( 0 ); comm0 = mpi_comm_self
    case( 1 ); if ( mm(i) /= 1 ) comm0 = comm1d(i)
    case( 2 ); if ( mm(i) == 1 ) comm0 = comm2d(i)
    case( 3 ); comm0 = comm3d
    end select
end do
if ( any( nn < 1 ) ) then
    call mpi_comm_split( comm0, mpi_undefined, 0, comm, e )
    fh = mpi_file_null
    return
end if
call mpi_comm_split( comm0, 1, 0, comm, e )
if ( mode == 'r' ) then
    i = mpi_mode_rdonly
elseif ( oo(n) == 0 ) then
    i = mpi_mode_wronly + mpi_mode_create + mpi_mode_excl
else
    i = mpi_mode_wronly
end if
call mpi_file_set_errhandler( mpi_file_null, mpi_errors_are_fatal, e )
call mpi_file_open( comm, filename, i, mpi_info_null, fh, e )
call mpi_comm_size( comm, n, e  )
call mpi_comm_rank( comm, i, e  )
call mpi_comm_rank( mpi_comm_world, ip, e  )
if ( verb .and. i == 0 ) write( 0, '(i8,a,i2,a,i8,2a)' ) &
    ip, ' Opened', ndims, 'D', n, 'P file: ', trim( filename )
ftype = mpi_real
if ( ndims > 0 ) then
    mmm = pack( mm, mm > 1, mm )
    nnn = pack( nn, mm > 1, nn )
    ooo = pack( oo, mm > 1, oo )
    call mpi_type_create_subarray( ndims, mmm, nnn, ooo, mpi_order_fortran, mpi_real, ftype, e )
    call mpi_type_commit( ftype, e )
end if
call mpi_file_set_view( fh, offset, mpi_real, ftype, 'native', mpi_info_null, e )
end subroutine

end module

! Allocate arrays
module m_arrays
implicit none
contains

subroutine arrays
use m_globals
integer :: i1(3), i2(3), j, k, l, j1, k1, l1, j2, k2, l2

! 3d
j = nm(1)
k = nm(2)
l = nm(3)

! 3d vectors
allocate(          &
    vv(j,k,l,3),   &
    uu(j,k,l,3),   &
    w1(j,k,l,3),   &
    w2(j,k,l,3) )

if ( (eplasticity == 'plastic') .or. (ivols == 'yes') ) then
    allocate(          & 
        si1(j,k,l,3),  &
        si2(j,k,l,3),  &
        z1(j,k,l,3),   & 
        z2(j,k,l,3) )
end if

if ( eplasticity == 'plastic' ) then
    if ( master ) write( 0, * ) 'Elastoplastic Material'
    allocate(          &
        dep1(j,k,l,3), & 
        dep2(j,k,l,3), & 
        ep1(j,k,l,3),  &
        ep2(j,k,l,3) )
end if

! 3d scalars
allocate(         &
    vc(j,k,l),    &
    mr(j,k,l),    &
    lam(j,k,l),   &
    mu(j,k,l),    &
    gam(j,k,l),   &
!   qp(j,k,l),    &
!   qs(j,k,l),    &
    yy(j,k,l),    &
    s1(j,k,l),    &
    s2(j,k,l)     )

if ( eplasticity == 'plastic' ) then
    allocate(         & 
        mco(j,k,l),   &
        phi(j,k,l),   &
        epm(j,k,l),   &
        mur(j,k,l),   &
        r1(j,k,l),    &
        r2(j,k,l),    &
        r3(j,k,l),    &
        r4(j,k,l),    &
        r5(j,k,l) )    
end if

! pml nodes
i1 = min( i2node, i1pml ) - i1node + 1
i2 = i2node - max( i1node, i2pml ) + 1
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
allocate(         &
    p1(j1,k,l,3), &
    p2(j,k1,l,3), &
    p3(j,k,l1,3), &
    p4(j2,k,l,3), &
    p5(j,k2,l,3), &
    p6(j,k,l2,3)  )

! pml cells
i1 = min( i2cell, i1pml ) - i1cell + 1
i2 = i2cell - max( i1cell, i2pml - 1 ) + 1
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
allocate(         &
    g1(j1,k,l,3), &
    g2(j,k1,l,3), &
    g3(j,k,l1,3), &
    g4(j2,k,l,3), &
    g5(j,k2,l,3), &
    g6(j,k,l2,3)  )

! PML damping
allocate( dn1(npml), dn2(npml), dc1(npml), dc2(npml) )

! Fault
if ( ifn /= 0 ) then
    i1 = nm
    i1(ifn) = 1
else
    i1 = 0
end if
j = i1(1)
k = i1(2)
l = i1(3)

! Fault vectors
allocate(          &
    nhat(j,k,l,3), &
    t0(j,k,l,3),   &
    ts0(j,k,l,3),  &
    tp(j,k,l,3),   &
    t1(j,k,l,3),   &
    t2(j,k,l,3),   &
    t3(j,k,l,3)    )

! Fault scalars
if ( friction == 'slipweakening' ) then
    if ( master ) write( 0, * ) 'Slip-Weakening Friction'
    allocate(         & 
        mus(j,k,l),   &
        mud(j,k,l),   &
        dc(j,k,l) )
end if

if ( friction == 'rateandstate' ) then
    if ( master ) write( 0, * ) 'Rate-and-State Friction'
    allocate(         &
        af(j,k,l),    &
        bf(j,k,l),    &
        v0(j,k,l),    &
        f0(j,k,l),    &
        ll(j,k,l),    &
        fw(j,k,l),    &
        vw(j,k,l),    &
        psi(j,k,l),   &
        svtrl(j,k,l), &
        svold(j,k,l), &
        sv0(j,k,l),   &
        f4(j,k,l),    &
        f5(j,k,l),    &
        fun(j,k,l),   &
        dfun(j,k,l),  &
        delf(j,k,l)   )
end if

allocate(         &
    co(j,k,l),    &
    area(j,k,l),  &
    rhypo(j,k,l), &
    lamf(j,k,l),  &
    muf(j,k,l),   &
    sl(j,k,l),    &
    psv(j,k,l),   &
    trup(j,k,l),  &
    tarr(j,k,l),  &
    tn(j,k,l),    &
    ts(j,k,l),    &
    f1(j,k,l),    &
    f2(j,k,l),    &
    f3(j,k,l) )

if ( pcdep == 'yes' ) then
    if ( master ) write( 0, * ) 'Regularized Response to Tn Variation'
    allocate(         & 
        lpc(j,k,l),   &
        tnold(j,k,l), &
        tnpc(j,k,l)   )
end if

end subroutine

end module

! Field input and output
module m_fieldio
implicit none
integer, private :: itdebug = -1, idebug
type t_io
    character(32) :: filename      ! filename on disk for input or output
    character(6) :: field          ! field variable, see fieldnames.py for possibilities
    character(8) :: tfunc          ! see time_function in util.f90 for possibilities
    character(3) :: mode           ! 'r' read, 'w' write
    integer :: ii(3,4), nc, nb, ib, fh
    real :: x1(3), x2(3), val, period
    real, pointer :: buff(:,:)     ! buffer for storing mutliple time steps
    !XXX character(4) :: fields(32) ! field variable, see fieldnames.py for possibilities
    !XXX real, pointer :: buff(:,:,:)  ! buffer for storing mutliple time steps
    type( t_io ), pointer :: next  ! pointer to next member of the field i/o list 
end type t_io
type( t_io ), pointer :: io0, io, ioprev
contains

! Append linked list item
subroutine pappend
allocate( io%next )
io => io%next
io%next => io0
end subroutine

! Remove linked list item
subroutine pdelete
ioprev%next => io%next
deallocate( io )
io => ioprev
end subroutine

! Field I/O sequence
subroutine fieldio( passes, field, f )
use m_globals
use m_util
use m_collective
use m_frio
character(*), intent(in) :: passes, field
real, intent(inout) :: f(:,:,:)
character(4) :: pass
integer :: i1(3), i2(3), i3(3), i4(3), di(3), m(4), n(4), o(4), &
    it1, it2, dit, i, j, k, l, ipass
real :: val

! Start timer
val = timer( 2 )
!if ( verb ) write( 0, * ) 'Field I/O ', passes, field

! Pass loop
do ipass = 1, len( passes )
pass = passes(ipass:ipass)
io => io0

! I/O list loop
loop: do while( io%next%field /= 'head' )
ioprev => io
io => io%next

! 4D slice
i1 = io%ii(1,1:3) - nnoff
i2 = io%ii(2,1:3) - nnoff
di = io%ii(3,1:3)
it1 = io%ii(1,4)
it2 = io%ii(2,4)
dit = io%ii(3,4)

! Time indices
if ( it > it2 ) then
    call pdelete
    cycle loop
end if
if ( it < it1 ) cycle loop
if ( modulo( it - it1, dit ) /= 0 ) cycle loop

! Spatial indices
i3 = i1
i4 = i2
where( i1 < i1core ) i1 = i1 + ( (i1core - i1 - 1) / di + 1 ) * di
where( i2 > i2core ) i2 = i1 + (  i2core - i1    ) / di       * di
m(1:3) = (i4 - i3) / di + 1
n(1:3) = (i2 - i1) / di + 1
o(1:3) = (i1 - i3) / di

! Dimensionality
i3 = i1
i4 = i2
do i = 1, 3
    if ( size( f, i ) == 1 ) then
        if ( n(i) < 1 ) then
            call pdelete
            cycle loop
        end if
        i1(i) = 1
        i2(i) = 1
        m(i) = 1
        n(i) = 1
        o(i) = 0
    end if
end do

! Pass test
if ( pass == '<' .and. io%mode(2:2) == 'w' ) cycle loop
if ( pass == '>' .and. io%mode(2:2) /= 'w' ) cycle loop

!XXX loop over fields
if ( field /= io%field ) cycle loop

! I/O
val = io%val * time_function( io%tfunc, tm, dt, io%period )
select case( io%mode )
case( '=c', '+c' )
    call setcube( f, w1, i3, i4, di, io%x1, io%x2, val, io%mode )
case( '=C', '+C' )
    call setcube( f, w2, i3, i4, di, io%x1, io%x2, val, io%mode )
case( '=' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val
    end do
    end do
    end do
case( '+' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val
    end do
    end do
    end do
case( '=i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = val * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '+i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = f(j,k,l) + val * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '=s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val * s1(j,k,l)
    end do
    end do
    end do
case( '+s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val * s1(j,k,l)
    end do
    end do
    end do
case( '=r', '+r', '=R', '+R' )
    if ( io%mode(2:2) == 'R' ) then
        do i = 1, 3
            if ( m(i) == 1 ) then
                i1(i) = 1
                i2(i) = 1
                n(i) = 1
                o(i) = 0
            end if
        end do
    end if
    if ( io%ib < 0 ) then
        !XXX allocate( io%buff(io%nc,n(1)*n(2)*n(3),io%nb) )
        allocate( io%buff(n(1)*n(2)*n(3),io%nb) )
        io%ib = io%nb
        io%fh = frio_file_null
        if ( mpin /= 0 ) io%fh = file_null
    end if
    if ( io%ib == io%nb ) then
        n(4) = min( io%nb, (it2 - it) / dit + 1 )
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit
        str = 'in/' // io%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpin == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( io%fh, io%buff(:,:n(4)), 'r', str, m, n, o, mpin, verb )
        io%ib = 0
        if ( any( n < 1 ) ) then
            deallocate( io%buff )
            call pdelete
            cycle loop
        end if
        if ( any( io%buff(:,:n(4)) /= io%buff(:,:n(4)) ) .or. &
            maxval( io%buff(:,:n(4)) ) > huge( val ) ) then
            write( 0, * ) 'ERROR: NaN/Inf in ', io%filename
            stop
        end if
    end if
    io%ib = io%ib + 1
    i = 0
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        i = i + 1
        s1(j,k,l) = io%buff(i,io%ib)
    end do
    end do
    end do
    if ( any( di > 1 ) ) then
        i1 = io%ii(1,1:3) - nnoff
        i2 = io%ii(2,1:3) - nnoff
        if ( any( di > nhalo .and. np3 > 1 ) ) stop 'di too large for nhalo'
        call scalar_swap_halo( s1, nhalo )
        call interpolate( s1, i1, i2, di )
    end if
    if ( io%mode(2:2) == 'R' ) then
        if ( m(1) == 1 ) then
            i2(1) = size( s1, 1 )
            do i = 2, i2(1)
                s1(i,:,:) = s1(1,:,:)
            end do
        end if
        if ( m(2) == 1 ) then
            i2(2) = size( s1, 2 )
            do i = 2, i2(2)
                s1(:,i,:) = s1(:,1,:)
            end do
        end if
        if ( m(3) == 1 ) then
            i2(3) = size( s1, 3 )
            do i = 2, i2(3)
                s1(:,:,i) = s1(:,:,1)
            end do
        end if
    end if
    if ( io%mode(1:1) == '=' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = s1(j,k,l)
        end do
        end do
        end do
    elseif ( io%mode(1:1) == '+' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = f(j,k,l) + s1(j,k,l)
        end do
        end do
        end do
    end if
    if ( it == it2 ) then
        deallocate( io%buff )
        call pdelete
        cycle loop
    end if
case( '=w', '=wi' )
    if ( io%ib < 0 ) then
        !XXX allocate( io%buff(io%nc,n(1)*n(2)*n(3),io%nb) )
        allocate( io%buff(n(1)*n(2)*n(3),io%nb) )
        io%ib = 0
        io%fh = frio_file_null
        if ( mpout /= 0 ) io%fh = file_null
    end if
    if ( modulo( it, itstats ) /= 0 ) then
        select case( io%field )
        case( 'vm2' ); call vector_norm( f, vv, i1, i2, di )
        case( 'um2' ); call vector_norm( f, uu, i1, i2, di )
        case( 'wm2' ); call tensor_norm( f, w1, w2, i1, i2, di )
        case( 'am2' ); call vector_norm( f, w1, i1, i2, di )
        end select
    end if
    io%ib = io%ib + 1
    if ( io%mode == '=wi' .and. all( i1 == i2 ) ) then
        io%buff(1,io%ib) = 0.0
        do l = i1(3) - 1, i2(3)
        do k = i1(2) - 1, i2(2)
        do j = i1(1) - 1, i2(1)
            io%buff(1,io%ib) = io%buff(1,io%ib) + f(j,k,l) * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    else
        i = 0
        do l = i1(3), i2(3), di(3)
        do k = i1(2), i2(2), di(2)
        do j = i1(1), i2(1), di(1)
            i = i + 1
            io%buff(i,io%ib) = f(j,k,l)
        end do
        end do
        end do
    end if
    if ( io%ib == io%nb .or. it == it2 .or. modulo( it, itio ) == 0 ) then
        n(4) = io%ib
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit + 1 - n(4)
        str = 'out/' // io%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpout == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( io%fh, io%buff(:,:n(4)), 'w', str, m, n, o, mpout, verb )
        io%ib = 0
        if ( it == it2 .or. any( n < 1 ) ) then
            deallocate( io%buff )
            call pdelete
            cycle loop
        end if
    end if
case default
    write( 0, * ) "bad i/o mode '", trim( io%mode ), "' for ", trim( io%filename )
    stop
end select

end do loop
end do

! Debug output
i = scan( passes, '>' )
if ( i > 0 .and. debug > 3 .and. it <= 8 ) then
    if ( itdebug /= it ) then
        itdebug = it
        idebug = 0
    end if
    idebug = idebug + 1
    write( str, "(a,3(i4.4,'-'),a)" ) 'debug/f', it, ipid, idebug, field
    write( 0, * ) 'Opening file: ', trim( str )
    open( 1, file=str, status='replace' )
    do l = 1, size( f, 3 )
        write( 1, * ) it, l, field
        do k = 1, size( f, 2 )
            write( 1, * ) f(:,k,l)
        end do
    end do
    close( 1 )
end if

! Timer
if (sync) call barrier
iotimer = iotimer + timer( 2 )

end subroutine

!------------------------------------------------------------------------------!
! Field I/O sequence
subroutine fieldio2d( passes, field, f )
use m_globals
use m_util
use m_collective
use m_frio
character(*), intent(in) :: passes, field
real, intent(inout) :: f(:,:,:)
character(4) :: pass
integer :: i1(3), i2(3), temp_i2(3), i3(3), i4(3), di(3), m(4), n(4), o(4), &
    it1, it2, dit, i, j, k, l, ipass
real :: val

! Start timer
val = timer( 2 )
!if ( verb ) write( 0, * ) 'Field I/O ', passes, field

! Pass loop
do ipass = 1, len( passes )
pass = passes(ipass:ipass)
io => io0

! I/O list loop
loop: do while( io%next%field /= 'head' )
ioprev => io
io => io%next

! 4D slice
i1 = io%ii(1,1:3) - nnoff
i2 = io%ii(2,1:3) - nnoff
di = io%ii(3,1:3)
it1 = io%ii(1,4)
it2 = io%ii(2,4)
dit = io%ii(3,4)

! Time indices
if ( it > it2 ) then
    call pdelete
    cycle loop
end if
if ( it < it1 ) cycle loop
if ( modulo( it - it1, dit ) /= 0 ) cycle loop

! Spatial indices
i3 = i1
i4 = i2
where( i1 < i1core ) i1 = i1 + ( (i1core - i1 - 1) / di + 1 ) * di
where( i2 > i2core ) i2 = i1 + (  i2core - i1    ) / di       * di
m(1:3) = (i4 - i3) / di + 1
n(1:3) = (i2 - i1) / di + 1
o(1:3) = (i1 - i3) / di

! Dimensionality
i3 = i1
i4 = i2
do i = 1, 3
    if ( size( f, i ) == 1 ) then
        if ( n(i) < 1 ) then
            call pdelete
            cycle loop
        end if
        i1(i) = 1
        i2(i) = 1
        m(i) = 1
        n(i) = 1
        o(i) = 0
    end if
end do

! Pass test
if ( pass == '<' .and. io%mode(2:2) == 'w' ) cycle loop
if ( pass == '>' .and. io%mode(2:2) /= 'w' ) cycle loop

!XXX loop over fields
if ( field /= io%field ) cycle loop

! I/O
val = io%val * time_function( io%tfunc, tm, dt, io%period )
select case( io%mode )
case( '=c', '+c' )
    call setcube( f, w1, i3, i4, di, io%x1, io%x2, val, io%mode )
case( '=C', '+C' )
    call setcube( f, w2, i3, i4, di, io%x1, io%x2, val, io%mode )
case( '=' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val
    end do
    end do
    end do
case( '+' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val
    end do
    end do
    end do
case( '=i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = val * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '+i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = f(j,k,l) + val * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '=s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val * s1(j,k,l)
    end do
    end do
    end do
case( '+s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val * s1(j,k,l)
    end do
    end do
    end do
case( '=r', '+r', '=R', '+R' )
    if ( io%mode(2:2) == 'R' ) then
        do i = 1, 3
            if ( m(i) == 1 ) then
                i1(i) = 1
                i2(i) = 1
                n(i) = 1
                o(i) = 0
            end if
        end do
    end if
    if ( io%ib < 0 ) then
        !XXX allocate( io%buff(io%nc,n(1)*n(2)*n(3),io%nb) )
        allocate( io%buff(n(1)*n(2)*n(3),io%nb) )
        io%ib = io%nb
        io%fh = frio_file_null
        if ( mpin /= 0 ) io%fh = file_null
    end if
    if ( io%ib == io%nb ) then
        n(4) = min( io%nb, (it2 - it) / dit + 1 )
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit
        str = 'in/' // io%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpin == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( io%fh, io%buff(:,:n(4)), 'r', str, m, n, o, mpin, verb )
        io%ib = 0
        if ( any( n < 1 ) ) then
            deallocate( io%buff )
            call pdelete
            cycle loop
        end if
        if ( any( io%buff(:,:n(4)) /= io%buff(:,:n(4)) ) .or. &
            maxval( io%buff(:,:n(4)) ) > huge( val ) ) then
            write( 0, * ) 'ERROR: NaN/Inf in ', io%filename
            stop
        end if
    end if
    io%ib = io%ib + 1
    i = 0
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        i = i + 1
        s1(j,k,l) = io%buff(i,io%ib)
    end do
    end do
    end do
    if ( any( di > 1 ) ) then
        i1 = io%ii(1,1:3) - nnoff
        i2 = io%ii(2,1:3) - nnoff
        if ( any( di > nhalo .and. np3 > 1 ) ) stop 'di too large for nhalo'
        call scalar_swap_halo( s1, nhalo )
        call interpolate( s1, i1, i2, di )
    end if
    temp_i2 = i2
    if ( io%mode(2:2) == 'R' ) then
        if ( m(1) == 1 ) then
            temp_i2(1) = size( s1, 1 )
            do i = 2, temp_i2(1)
                s1(i,:,:) = s1(1,:,:)
            end do
        end if
        if ( m(2) == 1 ) then
            temp_i2(2) = size( s1, 2 )
            do i = 2, temp_i2(2)
                s1(:,i,:) = s1(:,1,:)
            end do
        end if
        if ( m(3) == 1 ) then
            temp_i2(3) = size( s1, 3 )
            do i = 2, temp_i2(3)
                s1(:,:,i) = s1(:,:,1)
            end do
        end if
    end if
    if ( io%mode(1:1) == '=' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = s1(j,k,l)
        end do
        end do
        end do
    elseif ( io%mode(1:1) == '+' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = f(j,k,l) + s1(j,k,l)
        end do
        end do
        end do
    end if
    if ( it == it2 ) then
        deallocate( io%buff )
        call pdelete
        cycle loop
    end if
case( '=w', '=wi' )
    if ( io%ib < 0 ) then
        !XXX allocate( io%buff(io%nc,n(1)*n(2)*n(3),io%nb) )
        allocate( io%buff(n(1)*n(2)*n(3),io%nb) )
        io%ib = 0
        io%fh = frio_file_null
        if ( mpout /= 0 ) io%fh = file_null
    end if
    if ( modulo( it, itstats ) /= 0 ) then
        select case( io%field )
        case( 'vm2' ); call vector_norm( f, vv, i1, i2, di )
        case( 'um2' ); call vector_norm( f, uu, i1, i2, di )
        case( 'wm2' ); call tensor_norm( f, w1, w2, i1, i2, di )
        case( 'am2' ); call vector_norm( f, w1, i1, i2, di )
        end select
    end if
    io%ib = io%ib + 1
    if ( io%mode == '=wi' .and. all( i1 == i2 ) ) then
        io%buff(1,io%ib) = 0.0
        do l = i1(3) - 1, i2(3)
        do k = i1(2) - 1, i2(2)
        do j = i1(1) - 1, i2(1)
            io%buff(1,io%ib) = io%buff(1,io%ib) + f(j,k,l) * &
                ( ( 1.0 - abs( io%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( io%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( io%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    else
        i = 0
        do l = i1(3), i2(3), di(3)
        do k = i1(2), i2(2), di(2)
        do j = i1(1), i2(1), di(1)
            i = i + 1
            io%buff(i,io%ib) = f(j,k,l)
        end do
        end do
        end do
    end if
    if ( io%ib == io%nb .or. it == it2 .or. modulo( it, itio ) == 0 ) then
        n(4) = io%ib
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit + 1 - n(4)
        str = 'out/' // io%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpout == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( io%fh, io%buff(:,:n(4)), 'w', str, m, n, o, mpout, verb )
        io%ib = 0
        if ( it == it2 .or. any( n < 1 ) ) then
            deallocate( io%buff )
            call pdelete
            cycle loop
        end if
    end if
case default
    write( 0, * ) "bad i/o mode '", trim( io%mode ), "' for ", trim( io%filename )
    stop
end select

end do loop
end do

! Debug output
i = scan( passes, '>' )
if ( i > 0 .and. debug > 3 .and. it <= 8 ) then
    if ( itdebug /= it ) then
        itdebug = it
        idebug = 0
    end if
    idebug = idebug + 1
    write( str, "(a,3(i4.4,'-'),a)" ) 'debug/f', it, ipid, idebug, field
    write( 0, * ) 'Opening file: ', trim( str )
    open( 1, file=str, status='replace' )
    do l = 1, size( f, 3 )
        write( 1, * ) it, l, field
        do k = 1, size( f, 2 )
            write( 1, * ) f(:,k,l)
        end do
    end do
    close( 1 )
end if

! Timer
if (sync) call barrier
iotimer = iotimer + timer( 2 )

end subroutine


!------------------------------------------------------------------------------!

subroutine setcube( f, x, i1, i2, di, x1, x2, r, mode )
real, intent(inout) :: f(:,:,:)
real, intent(in) :: x(:,:,:,:), x1(3), x2(3), r
integer, intent(in) :: i1(3), i2(3), di(3)
character(*), intent(in) :: mode
integer :: n(3), o(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
o = 0
where ( n == 1 ) o = 1 - i1
select case( mode(1:1) )
case( '=' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
    if( x(j,k,l,1) >= x1(1) .and. x(j,k,l,1) <= x2(1) .and. &
        x(j,k,l,2) >= x1(2) .and. x(j,k,l,2) <= x2(2) .and. &
        x(j,k,l,3) >= x1(3) .and. x(j,k,l,3) <= x2(3) ) &
        f(j+o(1),k+o(2),l+o(3)) = r
    end do
    end do
    end do
case( '+' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
    if( x(j,k,l,1) >= x1(1) .and. x(j,k,l,1) <= x2(1) .and. &
        x(j,k,l,2) >= x1(2) .and. x(j,k,l,2) <= x2(2) .and. &
        x(j,k,l,3) >= x1(3) .and. x(j,k,l,3) <= x2(3) ) &
        f(j+o(1),k+o(2),l+o(3)) = f(j+o(1),k+o(2),l+o(3)) + r
    end do
    end do
    end do
case default; stop 'error in cube'
end select
end subroutine

end module

! Collect statistics
module m_stats
real :: &
    amax, vmax, umax, wmax, &
    samax, svmax, sumax, slmax, &
    tsmax, tnmin, tnmax, tarrmax, &
    efric, estrain, moment,strdropint,&
    eradiat,slipint
contains

! Write statistics
subroutine stats
use m_globals
use m_collective
use m_util
logical, save :: init = .true., dofault = .false.
integer, save :: fh(17), j = 0
integer :: m, o, i
real :: rr
real, save, allocatable, dimension(:,:) :: &
    vstats, fstats, estats, gvstats, gfstats, gestats
! end

! Start timer
if ( verb ) write( 0, * ) 'Statistics'

! Allocate buffers
if ( init ) then
    init = .false.
    if ( faultnormal /= 0 ) then
        i = abs( faultnormal )
        if ( ip3(i) == ip3root(i) ) dofault = .true.
    end if
    allocate( vstats(4,itio), fstats(8,itio), estats(6,itio), &
        gvstats(4,itio), gfstats(8,itio), gestats(6,itio) )
    vstats = 0.0
    fstats = 0.0
    estats = 0.0
    gvstats = 0.0
    gfstats = 0.0
    gestats = 0.0
    fh = -1
    if ( mpout /= 0 ) fh = file_null
end if

! Buffer stats
if ( modulo( it, itstats ) == 0 ) then
    j = j + 1
    vstats(1,j) = amax
    vstats(2,j) = vmax
    vstats(3,j) = umax
    vstats(4,j) = wmax
    rr = maxval( vstats )
    if ( rr /= rr .or. rr > huge( rr ) ) stop 'NaN/Inf!'
    if ( dofault ) then
        fstats(1,j) = samax
        fstats(2,j) = svmax
        fstats(3,j) = sumax
        fstats(4,j) = slmax
        fstats(5,j) = tsmax
        fstats(6,j) = -tnmin
        fstats(7,j) = tnmax
        fstats(8,j) = tarrmax
        estats(1,j) = efric
        estats(2,j) = estrain
        estats(3,j) = moment
        estats(4,j) = eradiat
        estats(5,j) = strdropint
        estats(6,j) = slipint
    end if
end if

! Write stats
if ( j > 0 .and. ( modulo( it, itio ) == 0 .or. it == nt ) ) then
    rr = timer( 2 )
    call rreduce2( gvstats, vstats, 'max', ip3root )
    if ( dofault ) then
        call rreduce2( gfstats, fstats, 'max', ip2root )
        call rreduce2( gestats, estats, 'sum', ip2root )
    end if
    if (sync) call barrier
    mptimer = mptimer + timer( 2 )
    if ( master ) then
        m = nt / itstats
        o = it / itstats - j
        gvstats = sqrt( gvstats )
        call rio1( fh(1), gvstats(1,:j), 'w', 'stats/amax', m, o, mpout, verb )
        call rio1( fh(2), gvstats(2,:j), 'w', 'stats/vmax', m, o, mpout, verb )
        call rio1( fh(3), gvstats(3,:j), 'w', 'stats/umax', m, o, mpout, verb )
        call rio1( fh(4), gvstats(4,:j), 'w', 'stats/wmax', m, o, mpout, verb )
        if ( dofault ) then
            gfstats(6,:j) = -gfstats(6,:j)
            call rio1( fh(5),  gfstats(1,:j), 'w', 'stats/samax',   m, o, mpout, verb )
            call rio1( fh(6),  gfstats(2,:j), 'w', 'stats/svmax',   m, o, mpout, verb )
            call rio1( fh(7),  gfstats(3,:j), 'w', 'stats/sumax',   m, o, mpout, verb )
            call rio1( fh(8),  gfstats(4,:j), 'w', 'stats/slmax',   m, o, mpout, verb )
            call rio1( fh(9),  gfstats(5,:j), 'w', 'stats/tsmax',   m, o, mpout, verb )
            call rio1( fh(10), gfstats(6,:j), 'w', 'stats/tnmin',   m, o, mpout, verb )
            call rio1( fh(11), gfstats(7,:j), 'w', 'stats/tnmax',   m, o, mpout, verb )
            call rio1( fh(12), gfstats(8,:j), 'w', 'stats/tarrmax', m, o, mpout, verb )
            call rio1( fh(13), gestats(1,:j), 'w', 'stats/efric',   m, o, mpout, verb )
            call rio1( fh(14), gestats(2,:j), 'w', 'stats/estrain', m, o, mpout, verb )
            call rio1( fh(15), gestats(3,:j), 'w', 'stats/moment',  m, o, mpout, verb )
            call rio1( fh(16), gestats(4,:j), 'w', 'stats/eradiat', m, o, mpout, verb )
! print part of statistical data            
            do i = 1, j
                if ( gestats(3,i) > 0.0 ) then
                    gestats(3,i) = ( log10( gestats(3,i) ) - 9.05 ) / 1.5
                else
                    gestats(3,i) = -999
                end if
            end do
            call rio1( fh(17), gestats(3,:j), 'w', 'stats/mw',      m, o, mpout, verb )
        end if

    end if
    j = 0
    if (sync) call barrier
    iotimer = iotimer + timer( 2 )
end if

if ( it == nt .and. dofault) then
        estats(1,1) = efric
        estats(2,1) = estrain
        estats(3,1) = moment
        estats(4,1) = eradiat
        estats(5,1) = strdropint
        estats(6,1) = slipint
        call rreduce2( gestats, estats, 'sum', ip2root )
    if (master) then   
      write(0,*) 'strain Energy is ',gestats(2,1)/1e12,'*10^12 J'
      write(0,*) 'Frictional+Fracture Energy is ',gestats(1,1)/1e12,'*10^12 J'
      write(0,*) 'Radiation Energy is ',gestats(4,1)/1e12,'*10^12 J'
      write(0,*) 'Moment is ',gestats(3,1)/1e16, '*10^16 J'
      write(0,*) 'Moment magnitude is ',( log10( gestats(3,1) ) - 9.05 ) / 1.5
      write(0,*) 'Energy stress drop is', gestats(5,1)/gestats(6,1)/1e6,' MPa'
    end if
end if

end subroutine

end module

! Read model parameters
module m_parameters
implicit none
contains

subroutine read_parameters
use m_globals
use m_fieldio
integer :: ios, i
character(12) :: key
character(1) :: op
character(256) :: line

! I/O pointers
allocate( io0 )
io => io0
io%next => io0
io%field = 'head'

open( 1, file='parameters.py', status='old' )

doline: do

! Read line
read( 1, '(a)', iostat=ios ) line
if ( ios /= 0 ) exit doline

! Strip comments and punctuation
str = line
i = scan( str, '#' )
if ( i > 0 ) str(i:) = ' '
do
    i = scan( str, "()[]{}'," )
    if ( i == 0 ) exit
    str(i:i) = ' '
end do

! Read key val pair
if ( str == '' ) cycle doline
read( str, *, iostat=ios ) key

! Select input key
select case( key )
case( 'fieldio', '' )
case( 'nn' );           read( str, *, iostat=ios ) key, op, nn
case( 'nt' );           read( str, *, iostat=ios ) key, op, nt
case( 'dx' );           read( str, *, iostat=ios ) key, op, dx
case( 'dt' );           read( str, *, iostat=ios ) key, op, dt
case( 'tm0' );          read( str, *, iostat=ios ) key, op, tm0
case( 'affine' );       read( str, *, iostat=ios ) key, op, affine
case( 'n1expand' );     read( str, *, iostat=ios ) key, op, n1expand
case( 'n2expand' );     read( str, *, iostat=ios ) key, op, n2expand
case( 'rexpand' );      read( str, *, iostat=ios ) key, op, rexpand
case( 'gridnoise' );    read( str, *, iostat=ios ) key, op, gridnoise
case( 'oplevel' );      read( str, *, iostat=ios ) key, op, oplevel
case( 'rho1' );         read( str, *, iostat=ios ) key, op, rho1
case( 'rho2' );         read( str, *, iostat=ios ) key, op, rho2
case( 'vp1' );          read( str, *, iostat=ios ) key, op, vp1
case( 'vp2' );          read( str, *, iostat=ios ) key, op, vp2
case( 'vs1' );          read( str, *, iostat=ios ) key, op, vs1
case( 'vs2' );          read( str, *, iostat=ios ) key, op, vs2
case( 'gam1' );         read( str, *, iostat=ios ) key, op, gam1
case( 'gam2' );         read( str, *, iostat=ios ) key, op, gam2
case( 'vdamp' );        read( str, *, iostat=ios ) key, op, vdamp
case( 'hourglass' );    read( str, *, iostat=ios ) key, op, hourglass
case( 'bc1' );          read( str, *, iostat=ios ) key, op, bc1
case( 'bc2' );          read( str, *, iostat=ios ) key, op, bc2
case( 'npml' );         read( str, *, iostat=ios ) key, op, npml
case( 'i1pml' );        read( str, *, iostat=ios ) key, op, i1pml
case( 'i2pml' );        read( str, *, iostat=ios ) key, op, i2pml
case( 'ppml' );         read( str, *, iostat=ios ) key, op, ppml
case( 'vpml' );         read( str, *, iostat=ios ) key, op, vpml
case( 'ihypo' );        read( str, *, iostat=ios ) key, op, ihypo
case( 'source' );       read( str, *, iostat=ios ) key, op, source
case( 'timefunction' ); read( str, *, iostat=ios ) key, op, timefunction
case( 'period' );       read( str, *, iostat=ios ) key, op, period
case( 'source1' );      read( str, *, iostat=ios ) key, op, source1
case( 'source2' );      read( str, *, iostat=ios ) key, op, source2
case( 'nsource' );      read( str, *, iostat=ios ) key, op, nsource
case( 'ivols' );        read( str, *, iostat=ios ) key, op, ivols
case( 'eplasticity' );  read( str, *, iostat=ios ) key, op, eplasticity
case( 'tv' );           read( str, *, iostat=ios ) key, op, tv
case( 'friction' );     read( str, *, iostat=ios ) key, op, friction
case( 'pcdep' );        read( str, *, iostat=ios ) key, op, pcdep
case( 'faultnormal' );  read( str, *, iostat=ios ) key, op, faultnormal
case( 'slipvector' );   read( str, *, iostat=ios ) key, op, slipvector
case( 'faultopening' ); read( str, *, iostat=ios ) key, op, faultopening
case( 'vrup' );         read( str, *, iostat=ios ) key, op, vrup
case( 'rcrit' );        read( str, *, iostat=ios ) key, op, rcrit
case( 'trelax' );       read( str, *, iostat=ios ) key, op, trelax
case( 'rnucl' );        read( str, *, iostat=ios ) key, op, rnucl
case( 'tmnucl' );       read( str, *, iostat=ios ) key, op, tmnucl
case( 'delts' );        read( str, *, iostat=ios ) key, op, delts
case( 'svtol' );        read( str, *, iostat=ios ) key, op, svtol
case( 'np3' );          read( str, *, iostat=ios ) key, op, np3
case( 'itstats' );      read( str, *, iostat=ios ) key, op, itstats
case( 'itio' );         read( str, *, iostat=ios ) key, op, itio
case( 'itcheck' );      read( str, *, iostat=ios ) key, op, itcheck
case( 'itstop' );       read( str, *, iostat=ios ) key, op, itstop
case( 'debug' );        read( str, *, iostat=ios ) key, op, debug
case( 'mpin' );         read( str, *, iostat=ios ) key, op, mpin
case( 'mpout' );        read( str, *, iostat=ios ) key, op, mpout
case default
    select case( key(1:1) )
    case( '=', '+' )
        call pappend
        io%ib = -1
        !XXXread( str, *, iostat=ios ) io%mode, io%nc
        read( str, *, iostat=ios ) io%mode, io%nc, io%tfunc, &
            io%period, io%x1, io%x2, io%nb, io%ii, io%filename, &
            io%val, io%field
    case default; ios = 1
    end select
end select

! Error check
if ( ios /= 0 ) then
    if ( master ) write( 0, * ) 'bad input: ', trim( line )
    stop
end if

end do doline

close( 1 )

end subroutine

end module

! Setup model dimensions
module m_setup
implicit none
contains

subroutine setup
use m_globals
use m_collective
use m_util
integer :: nl(3)

nt = max( nt, 0 )
ifn = abs( faultnormal )

! Partition for parallelization
if ( np0 == 1 ) np3 = 1
nl3 = (nn - 1) / np3 + 1
nhalo = 1
if ( ifn /= 0 ) nhalo(ifn) = 2
nl3 = max( nl3, nhalo )
np3 = (nn - 1) / nl3 + 1
call rank( ip3, ipid, np3 )
nnoff = nl3 * ip3 - nhalo

! Master process
ip3root = (ihypo - 1.0) / nl3
master = all( ip3 == ip3root )

! Size of arrays
nl = min( nl3, nn - nnoff - nhalo )
nm = nl + 2 * nhalo

! Boundary conditions
i1bc = 1  - nnoff
i2bc = nn - nnoff

! Non-overlapping core region
i1core = 1  + nhalo
i2core = nm - nhalo

! Node region
i1node = max( i1bc, 2 )
i2node = min( i2bc, nm - 1 )

! Cell region
i1cell = max( i1bc, 1 )
i2cell = min( i2bc - 1, nm - 1 )

! PML region
i1pml = i1pml - nnoff
i2pml = i2pml - nnoff

! Map rupture index to local indices, and test if fault on this process
ip2root = ip3root
irup = 0
if ( ifn /= 0 ) then
    ip2root( ifn ) = -1
    irup = floor( ihypo(ifn) + 0.000001 ) - nnoff(ifn)
    if ( irup + 1 < i1core(ifn) .or. irup > i2core(ifn) ) ifn = 0
end if

! Debugging
verb = master .and. debug > 0
sync = debug > 1
if ( debug > 2 ) then
    write( str, "( a,i6.6,a )" ) 'debug/db', ipid, '.py'
    open( 1, file=str, status='replace' )
    write( 1, "( 'ifn     = ', i8                                            )" ) ifn
    write( 1, "( 'irup    = ', i8                                            )" ) irup
    write( 1, "( 'ip      = ', i8                                            )" ) ip
    write( 1, "( 'ipid    = ', i8                                            )" ) ipid
    write( 1, "( 'np3     = ', i8, 2(',', i8)                                )" ) np3
    write( 1, "( 'ip3     = ', i8, 2(',', i8)                                )" ) ip3
    write( 1, "( 'nn      = ', i8, 2(',', i8)                                )" ) nn
    write( 1, "( 'nm      = ', i8, 2(',', i8)                                )" ) nm
    write( 1, "( 'bc1     = ', i8, 2(',', i8)                                )" ) bc1
    write( 1, "( 'bc2     = ', i8, 2(',', i8)                                )" ) bc2
    write( 1, "( 'nhalo   = ', i8, 2(',', i8)                                )" ) nhalo
    write( 1, "( 'nnoff   = ', i8, 2(',', i8)                                )" ) nnoff
    write( 1, "( 'i1bc    = ', i8, 2(',', i8), '; i2bc   = ', i8, 2(',', i8) )" ) i1bc, i2bc
    write( 1, "( 'i1pml   = ', i8, 2(',', i8), '; i2pml  = ', i8, 2(',', i8) )" ) i1pml, i2pml
    write( 1, "( 'i1core  = ', i8, 2(',', i8), '; i2core = ', i8, 2(',', i8) )" ) i1core, i2core
    write( 1, "( 'i1node  = ', i8, 2(',', i8), '; i2node = ', i8, 2(',', i8) )" ) i1node, i2node
    write( 1, "( 'i1cell  = ', i8, 2(',', i8), '; i2cell = ', i8, 2(',', i8) )" ) i1cell, i2cell
    close( 1 )
end if

end subroutine

end module

! Grid generation
module m_grid_gen
implicit none
contains

subroutine grid_gen
use m_globals
use m_collective
use m_bc
use m_util
use m_diffnc
use m_fieldio
use m_surfnormals
integer :: i1(3), i2(3), i3(3), i4(3), bc(3), &
    i, j, k, l, j1, k1, l1, j2, k2, l2, b, c
real :: m(9), tol, h
integer, allocatable :: seed(:)

if ( master ) write( 0, * ) 'Grid generation'

! Create rectangular mesh with double nodes at the fault
w1 = 0.0
i1 = i1core
i2 = i2core
do i = i1(1), i2(1); w1(i,:,:,1) = dx(1) * (i + nnoff(1) - 1); end do
do i = i1(2), i2(2); w1(:,i,:,2) = dx(2) * (i + nnoff(2) - 1); end do
do i = i1(3), i2(3); w1(:,:,i,3) = dx(3) * (i + nnoff(3) - 1); end do
if ( faultnormal /= 0 ) then
    i1 = max( i1core, irup + 1 )
    select case( abs( faultnormal ) )
    case( 1 ); do i = i1(1), i2(1); w1(i,:,:,1) = dx(1) * (i + nnoff(1) - 2); end do
    case( 2 ); do i = i1(2), i2(2); w1(:,i,:,2) = dx(2) * (i + nnoff(2) - 2); end do
    case( 3 ); do i = i1(3), i2(3); w1(:,:,i,3) = dx(3) * (i + nnoff(3) - 2); end do
    end select
end if

! Read grid
call fieldio( '<', 'x1', w1(:,:,:,1) )
call fieldio( '<', 'x2', w1(:,:,:,2) )
call fieldio( '<', 'x3', w1(:,:,:,3) )

! Add random noise except at boundaries and in PML
if ( gridnoise > 0.0 ) then
    call random_seed( size=i )
    allocate( seed(i) )
    seed = ip
    call random_seed( put=seed )
    call random_number( w2 )
    w2 = sqrt( sum( dx * dx ) ) * gridnoise * ( w2 - 0.5 )
    i1 = i1pml + 1
    i2 = i2pml - 1
    call set_halo( w2(:,:,:,1), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,2), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,3), 0.0, i1, i2 )
    i1 = i1bc + 1
    i2 = i2bc - 1
    call set_halo( w2(:,:,:,1), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,2), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,3), 0.0, i1, i2 )
    i1 = max( i1core, irup )
    i2 = min( i2core, irup + 1 )
    select case( abs( faultnormal ) )
    case( 1 ); w2(i1(1):i2(1),:,:,:) = 0.0
    case( 2 ); w2(:,i1(2):i2(2),:,:) = 0.0
    case( 3 ); w2(:,:,i1(3):i2(3),:) = 0.0
    end select
    w1 = w1 + w2
end if

! Grid expansion
if ( rexpand > 1.0 ) then
    i1 = n1expand - nnoff
    i2 = nn - n2expand + 1 - nnoff
    i3 = i1core
    i4 = i2core
    do j = i3(1), min( i4(1), i1(1) )
        i = i1(1) - j
        w1(j,:,:,1) = w1(j,:,:,1) + &
            dx(1) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do j = max( i3(1), i2(1) ), i4(1)
        i = j - i2(1)
        w1(j,:,:,1) = w1(j,:,:,1) - &
            dx(1) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do k = i3(2), min( i4(2), i1(2) )
        i = i1(2) - k
        w1(:,k,:,2) = w1(:,k,:,2) + &
            dx(2) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do k = max( i3(2), i2(2) ), i4(2)
        i = k - i2(2)
        w1(:,k,:,2) = w1(:,k,:,2) - &
            dx(2) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do l = i3(3), min( i4(3), i1(3) )
        i = i1(3) - l
        w1(:,:,l,3) = w1(:,:,l,3) + &
            dx(3) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do l = max( i3(3), i2(3) ), i4(3)
        i = l - i2(3)
        w1(:,:,l,3) = w1(:,:,l,3) - &
            dx(3) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
end if

! Affine grid transformation
m = affine
do l = 1, nm(3)
do k = 1, nm(2)
do j = 1, nm(1)
    w2(j,k,l,1) = m(1) * w1(j,k,l,1) + m(2) * w1(j,k,l,2) + m(3) * w1(j,k,l,3)
    w2(j,k,l,2) = m(4) * w1(j,k,l,1) + m(5) * w1(j,k,l,2) + m(6) * w1(j,k,l,3)
    w2(j,k,l,3) = m(7) * w1(j,k,l,1) + m(8) * w1(j,k,l,2) + m(9) * w1(j,k,l,3)
end do
end do
end do
w1 = w2

! Fill halo, bc=4 means copy into halo, need this for nhat
bc = 4
i1 = i1bc - 1
i2 = i2bc + 1
call vector_swap_halo( w1, nhalo )
call vector_bc( w1, bc, bc, i1, i2 )

! Cell centers
call average( w2(:,:,:,1), w1(:,:,:,1), i1cell, i2cell, 1 )
call average( w2(:,:,:,2), w1(:,:,:,2), i1cell, i2cell, 1 )
call average( w2(:,:,:,3), w1(:,:,:,3), i1cell, i2cell, 1 )
call set_halo( w2(:,:,:,1), 0.0, i1cell, i2cell )
call set_halo( w2(:,:,:,2), 0.0, i1cell, i2cell )
call set_halo( w2(:,:,:,3), 0.0, i1cell, i2cell )

! Output
call fieldio( '>', 'x1', w1(:,:,:,1) )
call fieldio( '>', 'x2', w1(:,:,:,2) )
call fieldio( '>', 'x3', w1(:,:,:,3) )
call fieldio( '>', 'c1', w2(:,:,:,1) )
call fieldio( '>', 'c2', w2(:,:,:,2) )
call fieldio( '>', 'c3', w2(:,:,:,3) )

! Boundary surface normals
!j = nm(1)
!k = nm(2)
!l = nm(3)
!if ( bc1(1) == 10 ) then
!    allocate( pn1(1,k,l,3), gn1(1,k,l,3) )
!    pn1 = 0.0
!    gn1 = 0.0
!    i1 = i1node
!    i2 = i2node
!    i2(1) = i1(1)
!    call nodenormals( pn1, w1, dx, i1, i2, 1 )
!    i1 = i1cell
!    i2 = i2cell
!    i2(1) = i1(1)
!    call cellnormals( gn1, w1, dx, i1, i2, 1 )
!    if ( nl3(1) < npml ) then
!        root = (/0, -1, -1/)
!        call rbroadcast4( pn1, root )
!        call rbroadcast4( gn1, root )
!    end if
!end if
!if ( bc2(1) == 10 ) then
!    allocate( pn4(1,k,l,3), gn4(1,k,l,3) )
!    pn4 = 0.0
!    gn4 = 0.0
!    i1 = i1node
!    i2 = i2node
!    i1(1) = i2(1)
!    call nodenormals( pn4, w1, dx, i1, i2, 1 )
!    i1 = i1cell
!    i2 = i2cell
!    i1(1) = i2(1)
!    call cellnormals( gn4, w1, dx, i1, i2, 1 )
!    if ( nl3(1) < npml ) then
!        root = (/np3(1), -1, -1/)
!        call rbroadcast4( pn4, root )
!        call rbroadcast4( gn4, root )
!    end if
!end if

! Orthogonality test
if ( oplevel == 0 ) then
    oplevel = 6
    tol = 10.0 * epsilon( tol )
    j1 = i1cell(1); j2 = i2cell(1)
    k1 = i1cell(2); k2 = i2cell(2)
    l1 = i1cell(3); l2 = i2cell(3)
    if ( &
    sum( abs( w1(j1+1:j2+1,:,:,2) - w1(j1:j2,:,:,2) ) ) < tol .and. &
    sum( abs( w1(j1+1:j2+1,:,:,3) - w1(j1:j2,:,:,3) ) ) < tol .and. &
    sum( abs( w1(:,k1+1:k2+1,:,3) - w1(:,k1:k2,:,3) ) ) < tol .and. &
    sum( abs( w1(:,k1+1:k2+1,:,1) - w1(:,k1:k2,:,1) ) ) < tol .and. &
    sum( abs( w1(:,:,l1+1:l2+1,1) - w1(:,:,l1:l2,1) ) ) < tol .and. &
    sum( abs( w1(:,:,l1+1:l2+1,2) - w1(:,:,l1:l2,2) ) ) < tol ) oplevel = 2
end if

! Operators
select case( oplevel )
case( 1 )
case( 2 )
    allocate( dx1(nm(1)), dx2(nm(2)), dx3(nm(3)) )
    do i = 1, nm(1)-1; dx1(i) = w1(i+1,3,3,1) - w1(i,3,3,1); end do
    do i = 1, nm(2)-1; dx2(i) = w1(3,i+1,3,2) - w1(3,i,3,2); end do
    do i = 1, nm(3)-1; dx3(i) = w1(3,3,i+1,3) - w1(3,3,i,3); end do
case( 3:5 )
    allocate( xx(nm(1),nm(2),nm(3),3) )
    xx = w1
case( 6 )
    allocate( bb(nm(1),nm(2),nm(3),8,3) )
    do i = 1, 3
    h = sign( 1.0 / 12.0, product( dx ) )
    b = modulo( i, 3 ) + 1
    c = modulo( i + 1, 3 ) + 1
    do l = 1, nm(3)-1
    do k = 1, nm(2)-1
    do j = 1, nm(1)-1
    bb(j,k,l,1,i) = h * &
        ((w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j+1,k+1,l,c)-w1(j+1,k,l+1,c))+w1(j,k+1,l+1,b)*(w1(j,k,l+1,c)-w1(j,k+1,l,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j,k+1,l+1,c)-w1(j+1,k+1,l,c))+w1(j+1,k,l+1,b)*(w1(j+1,k,l,c)-w1(j,k,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j+1,k,l+1,c)-w1(j,k+1,l+1,c))+w1(j+1,k+1,l,b)*(w1(j,k+1,l,c)-w1(j+1,k,l,c)))
    bb(j,k,l,2,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j+1,k,l+1,c)-w1(j+1,k+1,l,c))+w1(j,k,l,b)*(w1(j,k+1,l,c)-w1(j,k,l+1,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j+1,k+1,l,c)-w1(j,k,l,c))+w1(j+1,k,l+1,b)*(w1(j,k,l+1,c)-w1(j+1,k+1,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j,k,l,c)-w1(j+1,k,l+1,c))+w1(j+1,k+1,l,b)*(w1(j+1,k+1,l+1,c)-w1(j,k+1,l,c)))
    bb(j,k,l,3,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j+1,k+1,l,c)-w1(j,k+1,l+1,c))+w1(j,k,l,b)*(w1(j,k,l+1,c)-w1(j+1,k,l,c)) &
        +(w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j,k,l,c)-w1(j+1,k+1,l,c))+w1(j,k+1,l+1,b)*(w1(j+1,k+1,l+1,c)-w1(j,k,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j,k+1,l+1,c)-w1(j,k,l,c))+w1(j+1,k+1,l,b)*(w1(j+1,k,l,c)-w1(j+1,k+1,l+1,c)))
    bb(j,k,l,4,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j,k+1,l+1,c)-w1(j+1,k,l+1,c))+w1(j,k,l,b)*(w1(j+1,k,l,c)-w1(j,k+1,l,c)) &
        +(w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j+1,k,l+1,c)-w1(j,k,l,c))+w1(j,k+1,l+1,b)*(w1(j,k+1,l,c)-w1(j+1,k+1,l+1,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j,k,l,c)-w1(j,k+1,l+1,c))+w1(j+1,k,l+1,b)*(w1(j+1,k+1,l+1,c)-w1(j+1,k,l,c)))
    bb(j,k,l,5,i) = h * &
        ((w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j,k+1,l,c)-w1(j,k,l+1,c))+w1(j+1,k,l,b)*(w1(j+1,k,l+1,c)-w1(j+1,k+1,l,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j,k,l+1,c)-w1(j+1,k,l,c))+w1(j,k+1,l,b)*(w1(j+1,k+1,l,c)-w1(j,k+1,l+1,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j+1,k,l,c)-w1(j,k+1,l,c))+w1(j,k,l+1,b)*(w1(j,k+1,l+1,c)-w1(j+1,k,l+1,c)))
    bb(j,k,l,6,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j,k,l+1,c)-w1(j,k+1,l,c))+w1(j+1,k+1,l+1,b)*(w1(j+1,k+1,l,c)-w1(j+1,k,l+1,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j+1,k+1,l+1,c)-w1(j,k,l+1,c))+w1(j,k+1,l,b)*(w1(j,k,l,c)-w1(j+1,k+1,l,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j,k+1,l,c)-w1(j+1,k+1,l+1,c))+w1(j,k,l+1,b)*(w1(j+1,k,l+1,c)-w1(j,k,l,c)))
    bb(j,k,l,7,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j+1,k,l,c)-w1(j,k,l+1,c))+w1(j+1,k+1,l+1,b)*(w1(j,k+1,l+1,c)-w1(j+1,k+1,l,c)) &
        +(w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j,k,l+1,c)-w1(j+1,k+1,l+1,c))+w1(j+1,k,l,b)*(w1(j+1,k+1,l,c)-w1(j,k,l,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j+1,k+1,l+1,c)-w1(j+1,k,l,c))+w1(j,k,l+1,b)*(w1(j,k,l,c)-w1(j,k+1,l+1,c)))
    bb(j,k,l,8,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j,k+1,l,c)-w1(j+1,k,l,c))+w1(j+1,k+1,l+1,b)*(w1(j+1,k,l+1,c)-w1(j,k+1,l+1,c)) &
        +(w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j+1,k+1,l+1,c)-w1(j,k+1,l,c))+w1(j+1,k,l,b)*(w1(j,k,l,c)-w1(j+1,k,l+1,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j+1,k,l,c)-w1(j+1,k+1,l+1,c))+w1(j,k+1,l,b)*(w1(j,k+1,l+1,c)-w1(j,k,l,c)))
    end do
    end do
    end do
    end do
case default; stop 'illegal operator'
end select

! Cell volume
call set_halo( vc, 0.0, i1cell, i2cell )
do i = 1, 3
    call diffnc( vc, w1, i, i, i1cell, i2cell, oplevel, bb, xx, dx1, dx2, dx3, dx )
    select case( ifn ) 
    case( 1 ); vc(irup,:,:) = 0.0
    case( 2 ); vc(:,irup,:) = 0.0
    case( 3 ); vc(:,:,irup) = 0.0
    end select
    if ( minval( vc ) < 0.0 ) stop 'negative cell volume, wrong sign in dx?'
end do
call fieldio( '>', 'vc', vc  )

end subroutine

end module

! Material model
module m_material
implicit none
contains

subroutine material
use m_globals
use m_collective
use m_util
use m_fieldio
real :: vstats(8), gvstats(8), r, rho_, vp_, vs_, gam_, courant
integer :: i1(3), i2(3)

if ( master ) write( 0, * ) 'Material model'

! Init
mr = 0.0
lam = 0.0
mu = 0.0
gam = 0.0

if ( eplasticity == 'plastic' ) then
    mur = 1.e20 
    mco = 0.0
    phi = 0.0
end if

! Inputs
call fieldio( '<', 'rho', mr  )
call fieldio( '<', 'vp',  lam  )
call fieldio( '<', 'vs',  mu  )
call fieldio( '<', 'gam', gam )

s1 = lam
s2 = mu

if ( eplasticity == 'plastic' ) then
    call fieldio( '<', 'mco', mco )
    call fieldio( '<', 'phi', phi )
    phi = atan( phi )
end if

! Limits
if ( rho1 > 0.0 ) mr = max( mr, rho1 )
if ( rho2 > 0.0 ) mr = min( mr, rho2 )
if ( vp1  > 0.0 ) s1 = max( s1, vp1 )
if ( vp2  > 0.0 ) s1 = min( s1, vp2 )
if ( vs1  > 0.0 ) s2 = max( s2, vs1 )
if ( vs2  > 0.0 ) s2 = min( s2, vs2 )

! Velocity dependent viscosity
if ( vdamp > 0.0 ) then
    gam = s2
    call invert( gam )
    gam = gam * vdamp
end if

! Limits
if ( gam1 > 0.0 ) gam = max( gam, gam1 )
if ( gam2 > 0.0 ) gam = min( gam, gam2 )

! Averages
vstats = 0.0
i1 = max( i1core, i1bc )
i2 = min( i2core, i2bc - 1 )
call set_halo( mr,  0.0, i1, i2 )
call set_halo( s1,  0.0, i1, i2 )
call set_halo( s2,  0.0, i1, i2 )
call set_halo( gam, 0.0, i1, i2 )
if ( eplasticity == 'plastic' ) then
    call set_halo( mco,  0.0, i1, i2 )
    call set_halo( phi,  0.0, i1, i2 )
end if

vstats(1) = sum( mr  )
vstats(2) = sum( s1  )
vstats(3) = sum( s2  )
vstats(4) = sum( gam )
call rreduce1( gvstats, vstats, 'sum', ip3root )
rho_ = gvstats(1) / product( nn - 1 ) 
vp_  = gvstats(2) / product( nn - 1 ) 
vs_  = gvstats(3) / product( nn - 1 ) 
gam_ = gvstats(4) / product( nn - 1 ) 

! Fill halo
call scalar_swap_halo( mr,  nhalo )
call scalar_swap_halo( s1,  nhalo )
call scalar_swap_halo( s2,  nhalo )
call scalar_swap_halo( gam, nhalo )
if ( eplasticity == 'plastic' ) then
    call scalar_swap_halo( mco, nhalo )
    call scalar_swap_halo( phi, nhalo )
end if

! Extrema
call set_halo( mr,  huge(r), i1cell, i2cell )
call set_halo( s1,  huge(r), i1cell, i2cell )
call set_halo( s2,  huge(r), i1cell, i2cell )
call set_halo( gam, huge(r), i1cell, i2cell )
vstats(1) = -minval( mr  )
vstats(2) = -minval( s1  )
vstats(3) = -minval( s2  )
vstats(4) = -minval( gam )
call set_halo( mr,  0.0, i1cell, i2cell )
call set_halo( s1,  0.0, i1cell, i2cell )
call set_halo( s2,  0.0, i1cell, i2cell )
call set_halo( gam, 0.0, i1cell, i2cell )
vstats(5) = maxval( mr  )
vstats(6) = maxval( s1  )
vstats(7) = maxval( s2  )
vstats(8) = maxval( gam )
call rreduce1( gvstats, vstats, 'allmax', (/0, 0, 0/) )
rho1 = -gvstats(1)
vp1  = -gvstats(2)
vs1  = -gvstats(3)
gam1 = -gvstats(4)
rho2 =  gvstats(5)
vp2  =  gvstats(6)
vs2  =  gvstats(7)
gam2 =  gvstats(8)

! Stats
if ( master ) then
    courant = dt * vp2 * 3.0 / sqrt( sum( dx * dx ) )
    open( 1, file='stats/material.py', status='replace' )
    write( 1, "( 'courant = ',g15.7 )" ) courant
    write( 1, "( 'rho_    = ',g15.7 )" ) rho_
    write( 1, "( 'rho1    = ',g15.7 )" ) rho1
    write( 1, "( 'rho2    = ',g15.7 )" ) rho2
    write( 1, "( 'vp_     = ',g15.7 )" ) vp_
    write( 1, "( 'vp1     = ',g15.7 )" ) vp1
    write( 1, "( 'vp2     = ',g15.7 )" ) vp2
    write( 1, "( 'vs_     = ',g15.7 )" ) vs_
    write( 1, "( 'vs1     = ',g15.7 )" ) vs1
    write( 1, "( 'vs2     = ',g15.7 )" ) vs2
    write( 1, "( 'gam_    = ',g15.7 )" ) gam_
    write( 1, "( 'gam1    = ',g15.7 )" ) gam1
    write( 1, "( 'gam2    = ',g15.7 )" ) gam2
    close( 1 )
end if

! Lame' parameters
mu  = mr * s2 * s2
lam = mr * s1 * s1 - 2.0 * mu


if ( eplasticity == 'plastic' ) then
    mur = mu 
    call invert( mur )
end if

! Hourglass constant
yy = 12.0 * (lam + 2.0 * mu)
call invert( yy )
yy = yy * sqrt( sum( dx * dx ) / 3.0 ) * mu * (lam + mu)
!yy = 0.3 / 16.0 * ( lam + 2.0 * mu ) * sqrt( sum( dx * dx ) / 3.0 ) ! like Ma & Liu, 2006

! Output
call fieldio( '>', 'rho', mr  )
call fieldio( '>', 'vp',  s1  )
call fieldio( '>', 'vs',  s2  )
call fieldio( '>', 'gam', gam )
call fieldio( '>', 'mu',  mu  )
call fieldio( '>', 'lam', lam )
call fieldio( '>', 'yy',  yy  )
if ( eplasticity == 'plastic' ) then
    call fieldio( '>', 'mco', mco )
    call fieldio( '>', 'phi', phi )
end if

end subroutine

!------------------------------------------------------------------------------!

! Calculate PML damping parameters
subroutine pml
use m_globals
integer :: i
real :: c1, c2, c3, damp, dampn, dampc, tune

if ( npml < 1 ) return
c1 =  8.0 / 15.0
c2 = -3.0 / 100.0
c3 =  1.0 / 1500.0
tune = 3.5
if ( vpml <= 0.0 ) vpml = 2.0 * vs1 * vs2 / (vs1 + vs2)
damp = tune * vpml / sqrt( sum( dx * dx ) / 3.0 ) * (c1 + (c2 + c3 * npml) * npml) / npml ** ppml
do i = 1, npml
    dampn = damp *  i ** ppml
    dampc = damp * (i ** ppml + (i - 1) ** ppml) * 0.5
    dn1(npml-i+1) = -2.0 * dampn       / (2.0 + dt * dampn)
    dc1(npml-i+1) = (2.0 - dt * dampc) / (2.0 + dt * dampc)
    dn2(npml-i+1) =  2.0               / (2.0 + dt * dampn)
    dc2(npml-i+1) =  2.0 * dt          / (2.0 + dt * dampc)
end do

end subroutine

end module

! Kinematic source
module m_source
implicit none
integer, private, allocatable :: src_nt(:)
real, private, allocatable :: src_xi(:,:), src_dt(:), src_t0(:), &
    src_w1(:,:), src_w2(:,:), src_history(:)
contains

! Initialize finite source
subroutine finite_source_init
use m_globals
use m_collective
use m_util
integer :: n, i, fh
if ( nsource == 0 ) return
if ( master ) write( 0, * ) 'Finite source initialize'
n = abs( nsource )
allocate( src_xi(n,3) )
fh = -1
if ( mpin /= 0 ) fh = file_null
call rio1( fh, src_xi(:,1), 'r', 'in/src_xi1', n, 0, mpin, verb )
call rio1( fh, src_xi(:,2), 'r', 'in/src_xi2', n, 0, mpin, verb )
call rio1( fh, src_xi(:,3), 'r', 'in/src_xi3', n, 0, mpin, verb )
if ( source == 'force' ) then
    do i = 1, 3
        src_xi(:,i) = src_xi(:,i) - nnoff(i)
        if ( all( src_xi(:,i) < (-1.0 + i1node(i)) ) .or. &
             all( src_xi(:,i) > ( 1.0 + i2node(i)) ) ) then
            nsource = 0
            deallocate( src_xi )
            return
        end if
    end do
    allocate( src_nt(n), src_dt(n), src_t0(n), src_w1(n,3) )
    call rio1( fh, src_w1(:,1), 'r', 'in/src_w11', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,2), 'r', 'in/src_w12', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,3), 'r', 'in/src_w13', n, 0, mpin, verb )
else
    do i = 1, 3
        src_xi(:,i) = src_xi(:,i) - 0.5 - nnoff(i)
        if ( all( src_xi(:,i) < (-1.0 + i1cell(i)) ) .or. &
             all( src_xi(:,i) > ( 1.0 + i2cell(i)) ) ) then
            nsource = 0
            deallocate( src_xi )
            return
        end if
    end do
    allocate( src_nt(n), src_dt(n), src_t0(n), src_w1(n,3), src_w2(n,3) )
    call rio1( fh, src_w1(:,1), 'r', 'in/src_w11', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,2), 'r', 'in/src_w22', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,3), 'r', 'in/src_w33', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,1), 'r', 'in/src_w23', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,2), 'r', 'in/src_w31', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,3), 'r', 'in/src_w12', n, 0, mpin, verb )
end if
call rio1( fh, src_t0, 'r', 'in/src_t0', n, 0, mpin, verb )
call rio1( fh, src_dt, 'r', 'in/src_nt', n, 0, mpin, verb )
src_nt = int( src_dt + 0.5 )
call rio1( fh, src_dt, 'r', 'in/src_dt', n, 0, mpin, verb )
n = sum( src_nt )
allocate( src_history(n) )
call rio1( fh, src_history, 'r', 'in/src_history', n, 0, mpin, verb )
end subroutine

! Add finite source to force vector or strain/stress tensor
subroutine finite_source
use m_globals
integer :: i1(3), i2(3), i, j, k, l, isrc, itoff
real :: xi(3), t, h, w
if ( nsource == 0 ) return
if ( verb ) write( 0, * ) 'Finite source'
itoff = 0
do isrc = 1, abs( nsource )
    i = floor( ( tm - src_t0(isrc) ) / src_dt(isrc) ) + 1
    xi = src_xi(isrc,:)
    if ( source == 'force' ) then
        i1 = max( i1node, floor( xi ) )
        i2 = min( i2node, floor( xi ) + 1 )
    else
        i1 = max( i1cell, floor( xi ) )
        i2 = min( i2cell, floor( xi ) + 1 )
    end if
    if ( i >= 0 .and. all( i2 >= i1 ) ) then
        i = min( i, src_nt(isrc) - 1 )
        t = src_t0(isrc) + src_dt(isrc) * (i - 1)
        h = min( 1.0, (tm - t) / src_dt(isrc) )
        if ( i == 0 ) then
            h = h * src_history(itoff+1)
        else
            h = ( 1.0 - h ) * src_history(itoff+i) + h * src_history(itoff+i+1)
        end if
        if ( source == 'force' ) then
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                w = h * ((1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)))
                do i = 1, 3
                    w1(j,k,l,i) = w1(j,k,l,i) + w * src_w1(isrc,i)
                end do
            end do
            end do
            end do
        else
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                w = h * vc(j,k,l) * ((1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)))
                do i = 1, 3
                    w1(j,k,l,i) = w1(j,k,l,i) - w * src_w1(isrc,i)
                    w2(j,k,l,i) = w2(j,k,l,i) - w * src_w2(isrc,i)
                end do
            end do
            end do
            end do
        end if
    end if
    itoff = itoff + src_nt(isrc)
end do
end subroutine

! Add point source to vector
subroutine vector_point_source
use m_globals
use m_util
integer :: i1(3), i2(3), i, j, k, l
real :: xi(3), f, w
if ( timefunction == 'none' ) return
xi = ihypo - nnoff
i1 = max( i1node, floor( xi ) )
i2 = min( i2node, floor( xi ) + 1 )
if ( any( i2 < i1 ) ) then
    timefunction = 'none'
    return
end if
if ( verb ) write( 0, * ) 'Point source'
f = time_function( timefunction, tm, dt, period )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    w = f * ( (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)) )
    do i = 1, 3
        w1(j,k,l,i) = w1(j,k,l,i) + w * source1(i)
    end do
end do
end do
end do
end subroutine

! Add point source to strain/stress tensor
subroutine tensor_point_source
use m_globals
use m_util
integer :: i1(3), i2(3), i, j, k, l
real :: xi(3), f, w
if ( timefunction == 'none' ) return
xi = ihypo - 0.5 - nnoff
i1 = max( i1cell, floor( xi ) )
i2 = min( i2cell, floor( xi ) + 1 )
if ( any( i2 < i1 ) ) then
    timefunction = 'none'
    return
end if
if ( verb ) write( 0, * ) 'Point source'
f = time_function( timefunction, tm, dt, period )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    w = f * vc(j,k,l) * ( (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)) )
    do i = 1, 3
        w1(j,k,l,i) = w1(j,k,l,i) - w * source1(i)
        w2(j,k,l,i) = w2(j,k,l,i) - w * source2(i)
    end do
end do
end do
end do
end subroutine

end module

! Initialization of volume stresses 
module m_inivolstress
implicit none
contains

subroutine inivolstress 
use m_globals
use m_diffcn
use m_bc
use m_util
use m_fieldio
use m_collective
integer :: i1(3), i2(3), i, ic, iid, id,   &
           j1, k1, l1, j2, k2, l2, j3, k3, l3, j4, k4, l4

if ( verb ) write( 0, * ) 'Initialization of volume stresses'

si1 = 0.0
si2 = 0.0

call fieldio( '<', 'a11', si1(:,:,:,1) )
call fieldio( '<', 'a22', si1(:,:,:,2) )
call fieldio( '<', 'a33', si1(:,:,:,3) )
call fieldio( '<', 'a23', si2(:,:,:,1) )
call fieldio( '<', 'a31', si2(:,:,:,2) )
call fieldio( '<', 'a12', si2(:,:,:,3) )

call vector_swap_halo( si1, nhalo )
call vector_swap_halo( si2, nhalo )

z1 = si1
z2 = si2

select case( ifn )
case( 1 ); z1(irup,:,:,:) = 0.0; z2(irup,:,:,:) = 0.0;
case( 2 ); z1(:,irup,:,:) = 0.0; z2(:,irup,:,:) = 0.0;
case( 3 ); z1(:,:,irup,:) = 0.0; z2(:,:,irup,:) = 0.0;
end select

call vector_swap_halo( z1, nhalo )
call vector_swap_halo( z2, nhalo )

s1 = 0.0
call set_halo( s1, 0.0, i1cell, i2cell )

! Loop over component and derivative direction
doic: do ic  = 1, 3
doid: do iid = 1, 3; id = modulo( ic + iid - 2, 3 ) + 1

! f_i = w_ij,j
i1 = i1node
i2 = i2node
if ( ic == id ) then
    call diffcn( s1, z1, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
else
    i = 6 - ic - id
    call diffcn( s1, z2, i, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
end if

! Add contribution to force vector
if ( ic == id ) then
    z1(:,:,:,ic) = s1
else
    z1(:,:,:,ic) = z1(:,:,:,ic) + s1
end if

end do doid
end do doic

call vector_bc( z1, bc1, bc2, i1bc, i2bc )
!call vector_swap_halo( z1, nhalo )

! Extract tractions on fault
i1 = 1
i2 = nm
i1(ifn) = irup
i2(ifn) = irup
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)

i1(ifn) = irup + 1
i2(ifn) = irup + 1
j3 = i1(1); j4 = i2(1)
k3 = i1(2); k4 = i2(2)
l3 = i1(3); l4 = i2(3)

f1 = area
call invert( f1 )

do i = 1, 3
      t0(:,:,:,i) = f1/2 * ( z1(j3:j4,k3:k4,l3:l4,i) - z1(j1:j2,k1:k2,l1:l2,i) )
end do

end subroutine

end module
! Rupture boundary condition
module m_rupture
implicit none
contains

! Rupture initialization
subroutine rupture_init
use m_globals
use m_collective
use m_surfnormals
use m_inivolstress
use m_util
use m_fieldio
use m_stats
real :: xhypo(3), xi(3), w  !, rr
integer :: i1(3), i2(3), i, j, k, l

if ( ifn /= 0 ) then
    i1 = i1core
    i2 = i2core
    i1(ifn) = irup
    i2(ifn) = irup
    call nodenormals( nhat, w1, dx, i1, i2, ifn )
    area = sign( 1, faultnormal ) * sqrt( sum( nhat * nhat, 4 ) )
 
    t0 = 0.
end if 

if ( ivols == 'yes' ) call inivolstress
if ( ifn == 0 )  return

if ( master ) write( 0, * ) 'Rupture initialization'

! I/O
t1 = 0.0
t2 = 0.0
t3 = 0.0

if ( friction == 'slipweakening' ) then
    co = 0.0
    mus = 0.0
    mud = 0.0
    dc = 0.0
    call fieldio2d( '<>', 'co',  co          )
    call fieldio2d( '<>', 'mus', mus         )
    call fieldio2d( '<>', 'mud', mud         )
    call fieldio2d( '<>', 'dc',  dc          )   
end if

if ( friction == 'rateandstate' ) then
    af = 0.0 
    bf = 0.0
    v0 = 0.0
    f0 = 0.0
    ll = 0.0
    fw = 0.0
    vw = 0.0
    psi = 0.0

    call fieldio2d( '<>', 'af',  af          )
    call fieldio2d( '<>', 'bf',  bf          )
    call fieldio2d( '<>', 'v0',  v0          )
    call fieldio2d( '<>', 'f0',  f0          )
    call fieldio2d( '<>', 'll',  ll          )
    call fieldio2d( '<>', 'fw',  fw          )
    call fieldio2d( '<>', 'vw',  vw          )
end if

if ( pcdep == 'yes' ) then
    lpc = 0.0
    call fieldio2d( '<>', 'lpc', lpc         )
end if

call fieldio2d( '<>', 's11', t1(:,:,:,1) )
call fieldio2d( '<>', 's22', t1(:,:,:,2) )
call fieldio2d( '<>', 's33', t1(:,:,:,3) )
call fieldio2d( '<>', 's23', t2(:,:,:,1) )
call fieldio2d( '<>', 's31', t2(:,:,:,2) )
call fieldio2d( '<>', 's12', t2(:,:,:,3) )
call fieldio2d( '<>', 'ts',  t3(:,:,:,1) )
call fieldio2d( '<>', 'td',  t3(:,:,:,2) )
call fieldio2d( '<>', 'tn',  t3(:,:,:,3) )

!! Normal traction check
!i1 = maxloc( t3(:,:,:,3) )
!rr = t3(i1(1),i1(2),i1(3),3)
!i1(ifn) = irup
!i1 = i1 + nnoff
!if ( rr > 0.0 ) write( 0, * ) 'warning: positive normal traction: ', rr, i1

! Lock fault in PML region
i1 = i1pml + 1
i2 = i2pml - 1
call set_halo( co, 1e20, i1, i2 )

! Normal vectors
!i1 = i1core
!i2 = i2core
!i1(ifn) = irup
!i2(ifn) = irup
!call nodenormals( nhat, w1, dx, i1, i2, ifn )
!area = sign( 1, faultnormal ) * sqrt( sum( nhat * nhat, 4 ) )

call fieldio2d( '>', 'nhat1', nhat(:,:,:,1) )
call fieldio2d( '>', 'nhat2', nhat(:,:,:,2) )
call fieldio2d( '>', 'nhat3', nhat(:,:,:,3) )

f1 = area
call invert( f1 )
do i = 1, 3
    nhat(:,:,:,i) = nhat(:,:,:,i) * f1
end do

do i = 1, 3
    j = modulo( i , 3 ) + 1
    k = modulo( i + 1, 3 ) + 1
    t0(:,:,:,i) = t0(:,:,:,i)   + &
    t1(:,:,:,i) * nhat(:,:,:,i) + &
    t2(:,:,:,j) * nhat(:,:,:,k) + &
    t2(:,:,:,k) * nhat(:,:,:,j)
end do

t2(:,:,:,1) = nhat(:,:,:,2) * slipvector(3) - nhat(:,:,:,3) * slipvector(2)
t2(:,:,:,2) = nhat(:,:,:,3) * slipvector(1) - nhat(:,:,:,1) * slipvector(3)
t2(:,:,:,3) = nhat(:,:,:,1) * slipvector(2) - nhat(:,:,:,2) * slipvector(1)
f1 = sqrt( sum( t2 * t2, 4 ) )
call invert( f1 )
do i = 1, 3
    t2(:,:,:,i) = t2(:,:,:,i) * f1
end do

t1(:,:,:,1) = t2(:,:,:,2) * nhat(:,:,:,3) - t2(:,:,:,3) * nhat(:,:,:,2)
t1(:,:,:,2) = t2(:,:,:,3) * nhat(:,:,:,1) - t2(:,:,:,1) * nhat(:,:,:,3)
t1(:,:,:,3) = t2(:,:,:,1) * nhat(:,:,:,2) - t2(:,:,:,2) * nhat(:,:,:,1)
f1 = sqrt( sum( t1 * t1, 4 ) )
call invert( f1 )
do i = 1, 3
    t1(:,:,:,i) = t1(:,:,:,i) * f1
end do

do i = 1, 3
    t0(:,:,:,i) = t0(:,:,:,i) + &
    t3(:,:,:,1) * t1(:,:,:,i) + &
    t3(:,:,:,2) * t2(:,:,:,i) + &
    t3(:,:,:,3) * nhat(:,:,:,i)
end do

f1 = sum( t0 * nhat, 4 ) 
do i = 1, 3
    ts0(:,:,:,i) = t0(:,:,:,i) - f1 * nhat(:,:,:,i)
end do

if ( ( rcrit > 0.0 .and. vrup > 0.0 ) .or. ( rnucl > 0.0 ) ) then
    xhypo = 0.0
    xi = ihypo - nnoff
    i1 = floor( xi )
    if ( all( i1 >= 1 .and. i1 < nm ) ) then
        do l = i1(3), i1(3)+1
        do k = i1(2), i1(2)+1
        do j = i1(1), i1(1)+1
            w = (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l))
            do i = 1, 3
                xhypo(i) = xhypo(i) + w * w1(j,k,l,i)
            end do
        end do
        end do
        end do
    end if
    call rbroadcast1( xhypo, ip2root )
    do i = 1, 3
        select case( ifn )
        case ( 1 ); t2(1,:,:,i) = w1(irup,:,:,i) - xhypo(i)
        case ( 2 ); t2(:,1,:,i) = w1(:,irup,:,i) - xhypo(i)
        case ( 3 ); t2(:,:,1,i) = w1(:,:,irup,i) - xhypo(i)
        end select
    end do
    rhypo = sqrt( sum( t2 * t2, 4 ) )
end if

! Resample mu on to fault plane nodes for moment calculatioin
select case( ifn )
case ( 1 ); lamf(1,:,:) = lam(irup,:,:); muf(1,:,:) = mu(irup,:,:)
case ( 2 ); lamf(:,1,:) = lam(:,irup,:); muf(:,1,:) = mu(:,irup,:)
case ( 3 ); lamf(:,:,1) = lam(:,:,irup); muf(:,:,1) = mu(:,:,irup)
end select
call invert( lamf )
call invert( muf )
j = nm(1) - 1
k = nm(2) - 1
l = nm(3) - 1
if ( ifn /= 1 ) lamf(2:j,:,:) = 0.5 * (lamf(2:j,:,:) + lamf(1:j-1,:,:))
if ( ifn /= 2 ) lamf(:,2:k,:) = 0.5 * (lamf(:,2:k,:) + lamf(:,1:k-1,:))
if ( ifn /= 3 ) lamf(:,:,2:l) = 0.5 * (lamf(:,:,2:l) + lamf(:,:,1:l-1))
if ( ifn /= 1 ) muf(2:j,:,:) = 0.5 * (muf(2:j,:,:) + muf(1:j-1,:,:))
if ( ifn /= 2 ) muf(:,2:k,:) = 0.5 * (muf(:,2:k,:) + muf(:,1:k-1,:))
if ( ifn /= 3 ) muf(:,:,2:l) = 0.5 * (muf(:,:,2:l) + muf(:,:,1:l-1))
call invert( muf )

! Initial state, can be overwritten by read_checkpoint
psv   =  0.0
trup  =  1e9
tarr  =  0.0
efric =  0.0

! Halos
call scalar_swap_halo( co,    nhalo )
call scalar_swap_halo( area,  nhalo )
call scalar_swap_halo( rhypo, nhalo )
call vector_swap_halo( nhat,  nhalo )
call vector_swap_halo( t0,    nhalo )
call vector_swap_halo( ts0,   nhalo )

if ( friction == 'slipweakening' ) then
    call scalar_swap_halo( mus,   nhalo )
    call scalar_swap_halo( mud,   nhalo )
    call scalar_swap_halo( dc,    nhalo )
end if

if ( friction == 'rateandstate' ) then
    call scalar_swap_halo( af,   nhalo )
    call scalar_swap_halo( bf,   nhalo )
    call scalar_swap_halo( v0,   nhalo )
    call scalar_swap_halo( f0,   nhalo )
    call scalar_swap_halo( ll,   nhalo )    
    call scalar_swap_halo( fw,   nhalo )
    call scalar_swap_halo( vw,   nhalo )
end if

if ( pcdep == 'yes' ) call scalar_swap_halo( lpc,  nhalo )

end subroutine

!------------------------------------------------------------------------------!

! Rupture boundary condition
subroutine rupture
use m_globals
use m_collective
use m_bc
use m_util
use m_fieldio
use m_stats
integer ::  niter, nmax, i1(3), i2(3), i, j, k, l,         &
           j1, k1, l1, j2, k2, l2, j3, k3, l3, j4, k4, l4
real :: tol

if ( ifn == 0 ) return
if ( verb ) write( 0, * ) 'Rupture'

if ( friction == 'rateandstate' ) then
    nmax = 30
    tol = 1.e-3
end if

! Indices
i1 = 1
i2 = nm
i1(ifn) = irup
i2(ifn) = irup
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
i1(ifn) = irup + 1
i2(ifn) = irup + 1
j3 = i1(1); j4 = i2(1)
k3 = i1(2); k4 = i2(2)
l3 = i1(3); l4 = i2(3)

if ( it == 1 ) then
    tp = 0.
else
    if ( tm < tmnucl ) then
        f2 = exp( (tm - tmnucl)**2/(tm*(tm -2*tmnucl)) )
    else
        f2 = 1.
    end if

    f1 = 0.
    where( rhypo < rnucl ) f1 = exp( rhypo**2/(rhypo**2-rnucl**2) ) * f2 * delts

    do i = 1, 3
        tp(:,:,:,i) = ts0(:,:,:,i) * f1
    end do
end if

if ( it == 1 ) then
    w2 = vv
    if ( maxval(abs(w2(:,:,:,1))) > 1.e-20 ) then
        vv(j3:j4,k3:k4,l3:l4,1) = w2(j3:j4,k3:k4,l3:l4,1)
        vv(j3:j4,k3:k4,l3:l4,2) = &
           - nhat(:,:,:,1)*nhat(:,:,:,2)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1)) * w2(j3:j4,k3:k4,l3:l4,1)
        vv(j3:j4,k3:k4,l3:l4,3) = &
           - nhat(:,:,:,1)*nhat(:,:,:,3)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1)) * w2(j3:j4,k3:k4,l3:l4,1)

        vv(j1:j2,k1:k2,l1:l2,1) = w2(j1:j2,k1:k2,l1:l2,1)
        vv(j1:j2,k1:k2,l1:l2,2) = &
           - nhat(:,:,:,1)*nhat(:,:,:,2)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1)) * w2(j1:j2,k1:k2,l1:l2,1)
        vv(j1:j2,k1:k2,l1:l2,3) = &
           - nhat(:,:,:,1)*nhat(:,:,:,3)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1)) * w2(j1:j2,k1:k2,l1:l2,1)
    end if
    if ( maxval(abs(w2(:,:,:,2))) > 1.e-20 ) then
        vv(j3:j4,k3:k4,l3:l4,1) = vv(j3:j4,k3:k4,l3:l4,1) &
           - nhat(:,:,:,1)*nhat(:,:,:,2)/(1 - nhat(:,:,:,2)*nhat(:,:,:,2)) * w2(j3:j4,k3:k4,l3:l4,2)
        vv(j3:j4,k3:k4,l3:l4,2) = vv(j3:j4,k3:k4,l3:l4,2) + w2(j3:j4,k3:k4,l3:l4,2)
        vv(j3:j4,k3:k4,l3:l4,3) = vv(j3:j4,k3:k4,l3:l4,2) &
           - nhat(:,:,:,2)*nhat(:,:,:,3)/(1 - nhat(:,:,:,2)*nhat(:,:,:,2)) * w2(j3:j4,k3:k4,l3:l4,2)

        vv(j1:j2,k1:k2,l1:l2,1) = vv(j1:j2,k1:k2,l1:l2,1) &
           - nhat(:,:,:,1)*nhat(:,:,:,2)/(1 - nhat(:,:,:,2)*nhat(:,:,:,2)) * w2(j1:j2,k1:k2,l1:l2,2)
        vv(j1:j2,k1:k2,l1:l2,2) = vv(j1:j2,k1:k2,l1:l2,2) + w2(j1:j2,k1:k2,l1:l2,2)
        vv(j1:j2,k1:k2,l1:l2,3) = vv(j1:j2,k1:k2,l1:l2,2) &
           - nhat(:,:,:,2)*nhat(:,:,:,3)/(1 - nhat(:,:,:,2)*nhat(:,:,:,2)) * w2(j1:j2,k1:k2,l1:l2,2)
    end if
    if ( maxval(abs(w2(:,:,:,3))) > 1.e-20 ) then
        vv(j3:j4,k3:k4,l3:l4,1) = vv(j3:j4,k3:k4,l3:l4,1) &
           - nhat(:,:,:,1)*nhat(:,:,:,3)/(1 - nhat(:,:,:,3)*nhat(:,:,:,3)) * w2(j3:j4,k3:k4,l3:l4,3)
        vv(j3:j4,k3:k4,l3:l4,2) = vv(j3:j4,k3:k4,l3:l4,2) &
           - nhat(:,:,:,2)*nhat(:,:,:,3)/(1 - nhat(:,:,:,3)*nhat(:,:,:,3)) * w2(j3:j4,k3:k4,l3:l4,3)
        vv(j3:j4,k3:k4,l3:l4,3) = vv(j3:j4,k3:k4,l3:l4,3) + w2(j3:j4,k3:k4,l3:l4,3)

        vv(j1:j2,k1:k2,l1:l2,1) = vv(j1:j2,k1:k2,l1:l2,1) &
           - nhat(:,:,:,1)*nhat(:,:,:,3)/(1 - nhat(:,:,:,3)*nhat(:,:,:,3)) * w2(j1:j2,k1:k2,l1:l2,3)
        vv(j1:j2,k1:k2,l1:l2,2) = vv(j1:j2,k1:k2,l1:l2,2) &
           - nhat(:,:,:,2)*nhat(:,:,:,3)/(1 - nhat(:,:,:,3)*nhat(:,:,:,3)) * w2(j1:j2,k1:k2,l1:l2,3)
        vv(j1:j2,k1:k2,l1:l2,3) = vv(j1:j2,k1:k2,l1:l2,3) + w2(j1:j2,k1:k2,l1:l2,3)
    end if

!    do i = 2, 3
!    vv(j3:j4,k3:k4,l3:l4,i) = -vv(j3:j4,k3:k4,l3:l4,1) * nhat(:,:,:,i) * &
!                              nhat(:,:,:,1)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1))
!    vv(j1:j2,k1:k2,l1:l2,i) = -vv(j1:j2,k1:k2,l1:l2,1) * nhat(:,:,:,i) * &
!                              nhat(:,:,:,1)/(1 - nhat(:,:,:,1)*nhat(:,:,:,1))
!    end do 
end if
!---------------------------------------------------------------

! Trial traction for zero velocity and zero displacement
! parameter 'c' defined in (5c) in front of normal traction
f3 = area * ( mr(j1:j2,k1:k2,l1:l2) + mr(j3:j4,k3:k4,l3:l4) )
f1 = dt * dt * f3; 
call invert( f1 )

do i = 1, 3
    t1(:,:,:,i) = t0(:,:,:,i) + tp(:,:,:,i) + f1 * dt * &
        ( vv(j3:j4,k3:k4,l3:l4,i) &
        - vv(j1:j2,k1:k2,l1:l2,i) &
        + w1(j3:j4,k3:k4,l3:l4,i) * mr(j3:j4,k3:k4,l3:l4) * dt &
        - w1(j1:j2,k1:k2,l1:l2,i) * mr(j1:j2,k1:k2,l1:l2) * dt )
    t2(:,:,:,i) = t1(:,:,:,i) + f1 * &
        ( uu(j3:j4,k3:k4,l3:l4,i) - uu(j1:j2,k1:k2,l1:l2,i) )
end do

! Normal and Shear traction  [ZS]
tn = sum( t2 * nhat, 4 )
!if ( faultopening == 1 ) tn = min( 0.0, tn )
tn = min( 0.0, tn )

f1 = sum( t1 * nhat, 4 ) 
do i = 1, 3
    t3(:,:,:,i) = t1(:,:,:,i) - f1 * nhat(:,:,:,i)
end do
ts = sqrt( sum( t3 * t3, 4 ) )

! slip velocity from the previous step
do i = 1, 3     
    t2(:,:,:,i) = vv(j3:j4,k3:k4,l3:l4,i) - vv(j1:j2,k1:k2,l1:l2,i)
end do

if ( friction == 'rateandstate' ) then

svold = sqrt( sum( t2 * t2, 4 ) )
! call scalar_swap_halo( sv0,   nhalo )

if ( it == 1 )  then
   
    psi = af * log( 2.0 * v0 / svold * sinh( ts / (-tn) / af ) )
    f1 = ts
    sv0 = svold
   
    if ( pcdep == 'yes' ) then 
        tnpc = tn 
        tnold = tn
    end if  
else
    where ( svold < sv0 ) svold = sv0
   
    if ( pcdep == 'yes' ) then 
        tnpc = tnpc + dt * svold / lpc *( tnold - tnpc )
        tnold = tn
    end if

    svtrl = ts * f3 * dt  

    f1 = f0 - ( bf - af ) * log( svold / v0 ) 
    
    where ( svold < 1.e-5 )
        f2 = f1
    elsewhere
        f2 = fw + ( f1 - fw ) / ( 1.0 + (svold / vw )**8.0 )**(1.0/8.0)  
    end where
        
    f2 = af * ( log( 2 * v0 ) + log( sinh(f2/af) ) - log( svold ) ) 

    f4 = exp( - svold * dt / ll )
    
    psi = psi * f4 + ( 1.0 - f4 ) * f2 

    f1 = 0.5 * svtrl / v0 * exp( psi / af ) 
    where ( f1 > 1.e6 )
        f1 = af * ( log(svtrl) - log(v0) ) + psi         
    elsewhere
        f1 = af * log( f1 + sqrt( f1*f1 + 1.0 ) )
    end where

    f2 = 0.5 * svold / v0 * exp( psi / af )  
    where ( f2 > 1.e6 )
        f2 = af * ( log(svold) - log(v0) ) + psi         
    elsewhere
        f2 = af * log( f2 + sqrt( f2*f2 + 1.0 ) )
    end where
    
    f1 = 0.5 * ( f1 + f2 ) 

    if ( pcdep == 'yes' ) then
        f4 = dt * f3 * (-tnpc)
    else
        f4 = dt * f3 * (-tn)
    end if
     
    f2 = psi + 0.82   
    where (f1 > f2)  f1 = f2

    i1 = i1node
    i2 = i2node
    i1(ifn) = 1
    i2(ifn) = 1
    delf = 1.0   

    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)

    niter = 0
    
    do while ( abs(delf(j,k,l)) > tol .and. niter <= nmax ) 

        fun(j,k,l) = svtrl(j,k,l) - f4(j,k,l) * f1(j,k,l) - v0(j,k,l) * & 
             ( exp((f1(j,k,l)-psi(j,k,l))/af(j,k,l)) - exp(-(f1(j,k,l)+psi(j,k,l))/af(j,k,l)) )
        dfun(j,k,l) = -f4(j,k,l) - ( exp((f1(j,k,l)-psi(j,k,l))/af(j,k,l)) + &
             exp(-(f1(j,k,l)+psi(j,k,l))/af(j,k,l)) ) *V0(j,k,l) / af(j,k,l)

        delf(j,k,l) = fun(j,k,l) / dfun(j,k,l)
        f1(j,k,l) = f1(j,k,l) - delf(j,k,l)

        niter = niter + 1
!        call set_halo( delf, -1.0, i1core, i2core) 
    end do

    end do
    end do
    end do
    !------------------------------------------  
    
    if ( pcdep == 'yes' ) then 
        f1 = -min( 0.0, tnpc ) * f1
    else
        f1 = -min( 0.0, tn ) * f1
    end if
    ! Shear traction bounded by friction
    f2 = f1 / ts
    do i = 1, 3
        t3(:,:,:,i) = f2 * t3(:,:,:,i)
    end do
    ts = f1

end if

end if

if ( friction == 'slipweakening' ) then

if ( it > 1 ) then 
   ! Slip-weakening friction law
    f1 = mud
    where ( sl < dc ) f1 = f1 + (1.0 - sl / dc) * (mus - mud)
    f1 = -min( 0.0, tn ) * f1 + co

    ! Nucleation
    if ( rcrit > 0.0 .and. vrup > 0.0 ) then
        f2 = 1.0
        if ( trelax > 0.0 ) f2 = min( (tm - rhypo / vrup) / trelax, 1.0 )
        f2 = (1.0 - f2) * ts + f2 * (-tn * mud + co)
        where ( rhypo < min( rcrit, tm * vrup ) .and. f2 < f1 ) f1 = f2
    end if

    ! Shear traction bounded by friction
    f2 = 1.0
    where ( ts > f1 ) f2 = f1 / ts
    do i = 1, 3
        t3(:,:,:,i) = f2 * t3(:,:,:,i)
    end do
    ts = min( ts, f1 )
end if

end if

! Total traction
do i = 1, 3
    t1(:,:,:,i) = t3(:,:,:,i) + tn * nhat(:,:,:,i)
end do

! Update acceleration
do i = 1, 3
    f2 = area * ( t1(:,:,:,i) - t0(:,:,:,i)  - tp(:,:,:,i) )
    w1(j1:j2,k1:k2,l1:l2,i) = w1(j1:j2,k1:k2,l1:l2,i) + f2
    w1(j3:j4,k3:k4,l3:l4,i) = w1(j3:j4,k3:k4,l3:l4,i) - f2
end do
call vector_bc( w1, bc1, bc2, i1bc, i2bc )

! Output
call fieldio( '>', 't1',  t1(:,:,:,1) )
call fieldio( '>', 't2',  t1(:,:,:,2) )
call fieldio( '>', 't3',  t1(:,:,:,3) )
call fieldio( '>', 'ts1', t3(:,:,:,1) )
call fieldio( '>', 'ts2', t3(:,:,:,2) )
call fieldio( '>', 'ts3', t3(:,:,:,3) )
call fieldio( '>', 'tsm', ts          )
call fieldio( '>', 'tnm', tn          )
call fieldio( '>', 'fr',  f1          )

if ( friction == 'rateandstate' ) then
    call fieldio( '>', 'psi', psi         )
end if

call set_halo( ts,      -1.0, i1core, i2core ); tsmax = maxval( ts ) 
call set_halo( tn,  huge(dt), i1core, i2core ); tnmin = minval( tn )
call set_halo( tn, -huge(dt), i1core, i2core ); tnmax = maxval( tn )
call set_halo( tn,       0.0, i1core, i2core )

! Friction + fracture energy
t2 = vv(j3:j4,k3:k4,l3:l4,:) - vv(j1:j2,k1:k2,l1:l2,:)
f2 = sum( t1 * t2, 4 ) * area
call set_halo( f2, 0.0, i1core, i2core )
efric = efric + dt * sum( f2 )

! Strain energy
t2 = uu(j3:j4,k3:k4,l3:l4,:) - uu(j1:j2,k1:k2,l1:l2,:)
f2 = sum( (t0 + t1) * t2, 4 ) * area
call set_halo( f2, 0.0, i1core, i2core )
estrain = 0.5 * sum( f2 )

! Radiation energy
eradiat = estrain - efric

! Stress drop 
!t2 = uu(j3:j4,k3:k4,l3:l4,:) - uu(j1:j2,k1:k2,l1:l2,:)
f2 = sum((t0 - t1) * t2,4) * area
call set_halo( f2, 0.0, i1core, i2core)
strdropint = sum( f2 ) 
f2 = sqrt(sum(t2*t2,4))*area
call set_halo( f2, 0.0, i1core, i2core)
slipint = sum( f2 )

! Moment (negelcts opening lambda contribution)
f2 = muf * area * sqrt( sum( t2 * t2, 4 ) )
call set_halo( f2, 0.0, i1core, i2core )
moment = sum( f2 )

! Slip acceleration
do i = 1, 3
    t2(:,:,:,i) = &
        w1(j3:j4,k3:k4,l3:l4,i) * mr(j3:j4,k3:k4,l3:l4) - &
        w1(j1:j2,k1:k2,l1:l2,i) * mr(j1:j2,k1:k2,l1:l2)
end do
f2 = sqrt( sum( t2 * t2, 4 ) )
call fieldio( '>', 'sa1', t2(:,:,:,1) )
call fieldio( '>', 'sa2', t2(:,:,:,2) )
call fieldio( '>', 'sa3', t2(:,:,:,3) )
call fieldio( '>', 'sam', f2          )
call set_halo( f2, -1.0, i1core, i2core )
samax = maxval( f2 )

end subroutine

end module

! Resample material arrays
module m_resample
implicit none
contains

subroutine resample
use m_globals
use m_collective
use m_bc
use m_util
integer :: i1(3), i2(3), bc(3)

if ( master ) write( 0, * ) 'Resample material model'

! Mass ratio
s2 = mr * vc
call average( mr, s2, i1node, i2node, -1 )
call invert( mr )
call scalar_swap_halo( mr, nhalo )
call scalar_bc( mr, bc1, bc2, i1bc, i2bc )

! Invert cell volume
call invert( vc )

! Viscosity, bc=4 means copy into halo for resampling at the node
bc = 4
i1 = i1bc - 1
i2 = i2bc
call scalar_bc( gam, bc, bc, i1, i2 )
s2 = gam * dt
call average( gam, s2, i1node, i2node, -1 )
call set_halo( gam, 0.0, i1bc, i2bc )
call scalar_swap_halo( gam, nhalo )
call scalar_bc( gam, bc1, bc2, i1bc, i2bc )

! Zero hourglass viscosity outside boundary, and at fault cell
i1 = i1bc
i2 = i2bc - 1
call set_halo( yy, 0.0, i1, i2 )
select case( ifn )
case( 1 ); yy(irup,:,:) = 0.0
case( 2 ); yy(:,irup,:) = 0.0
case( 3 ); yy(:,:,irup) = 0.0
end select

! Initial state
tm = 0.0
vv = 0.0
uu = 0.0
w1 = 0.0
w2 = 0.0
sl = 0.0
p1 = 0.0
p2 = 0.0
p3 = 0.0
p4 = 0.0
p5 = 0.0
p6 = 0.0
g1 = 0.0
g2 = 0.0
g3 = 0.0
g4 = 0.0
g5 = 0.0
g6 = 0.0
s1 = 0.0
s2 = 0.0

if ( eplasticity == 'plastic' ) then
    epm = 0.0  
    dep1 = 0.0 
    dep2 = 0.0
    ep1 = 0.0
    ep2 = 0.0
    z1 = 0.0
    z2 = 0.0
    r1 = 0.0
    r2 = 0.0
    r3 = 0.0
    r4 = 0.0
    r5 = 0.0
end if

end subroutine

end module

! Checkpoint restart
module m_checkpoint
implicit none
integer, private :: itcheck0
contains

! Look for checkpoint
subroutine look_for_checkpoint
use m_globals
use m_collective
use m_util
integer :: i
real :: r
r = timer( 2 )
write( str, '(a,i6.6)' ) 'checkpoint/it', ipid
open( 1, file=str, status='old', iostat=i )
if ( i == 0 ) then
    read( 1, * ) it, itcheck0
    close( 1 )
else
    it = 0
end if
call ireduce( i, it, 'allmin', (/0, 0, 0/) )
it = i
iotimer = iotimer + timer( 2 )
end subroutine

! Read checkpoint
subroutine read_checkpoint
use m_globals
use m_stats
use m_util
integer :: i
real :: r
r = timer( 2 )
if ( it == 0 ) return
if ( master ) write( 0, * ) 'Checkpoint found, starting from ', it
i = modulo( it / itcheck0, 2 )
write( str, '(a,i6.6,a,i6.6)' ) 'checkpoint/cp', i, '-', ipid
inquire( iolength=i ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
open( 1, file=str, recl=i, form='unformatted', access='direct', status='old' )
read( 1, rec=1 ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
close( 1 )
iotimer = iotimer + timer( 2 )
end subroutine

! Write checkpoint
subroutine write_checkpoint
use m_globals
use m_stats
use m_util
use m_collective
integer :: i
real :: r
r = timer( 2 )
if ( verb ) write( 0, * ) 'Checkpoint'
if ( itcheck >= 0 .and. ( it == nt .or. modulo( it, itio ) == 0 ) ) then
    open( 1, file='itcheck', status='old', iostat=i )
    if ( i == 0 ) then
        read( 1, * ) itcheck
        close( 1 )
    end if
end if
iotimer = iotimer + timer( 2 )
if ( itcheck <= 0 ) return
if ( modulo( it, itcheck ) /= 0 ) return
i = modulo( it / itcheck, 2 )
write( str, '(a,i6.6,a,i6.6)' ) 'checkpoint/cp', i, '-', ipid
inquire( iolength=i ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
open( 1, file=str, recl=i, form='unformatted',access='direct',status='replace' )
write( 1, rec=1 ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
close( 1 )
write( str, '(a,i6.6)' ) 'checkpoint/it', ipid
open( 1, file=str, status='replace' )
write( 1, * ) it, itcheck
close( 1 )
if (sync) call barrier
iotimer = iotimer + timer( 2 )
end subroutine

end module

! Time integration
module m_timestep
implicit none
contains

subroutine timestep
use m_globals
use m_util
use m_fieldio
use m_stats

! Status
if ( master ) then
    if ( verb ) then
        write( 0, * ) 'Time step', it
    else
        write( 0, '(a)', advance='no' ) '.'
        if ( modulo( it, 50 ) == 0 .or. it == nt ) write( 0, '(i6)' ) it
    end if
end if

! Save previous slip velocity
if ( ifn /= 0 ) then
    select case( ifn )
    case( 1 ); t2(1,:,:,:) = vv(irup+1,:,:,:) - vv(irup,:,:,:)
    case( 2 ); t2(:,1,:,:) = vv(:,irup+1,:,:) - vv(:,irup,:,:)
    case( 3 ); t2(:,:,1,:) = vv(:,:,irup+1,:) - vv(:,:,irup,:)
    end select
    f2 = sqrt( sum( t2 * t2, 4 ) )
end if

! Velocity time integration
tm = tm0 + dt * ( it - 1 ) - dt * 0.5
vv = vv + dt * w1
call fieldio( '<>', 'v1', vv(:,:,:,1) )
call fieldio( '<>', 'v2', vv(:,:,:,2) )
call fieldio( '<>', 'v3', vv(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, vv, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    vmax = maxval( s1 )
end if
call fieldio( '>', 'vm2', s1  )

! Displacement time integration
tm = tm0 + dt * ( it - 1 )
uu = uu + dt * vv
call fieldio( '<>', 'u1', uu(:,:,:,1) )
call fieldio( '<>', 'u2', uu(:,:,:,2) )
call fieldio( '<>', 'u3', uu(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, uu, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    umax = maxval( s1 )
end if
call fieldio( '>', 'um2', s1  )

! Fault time integration
if ( ifn /= 0 ) then
    select case( ifn )
    case( 1 ); t1(1,:,:,:) = vv(irup+1,:,:,:) - vv(irup,:,:,:)
    case( 2 ); t1(:,1,:,:) = vv(:,irup+1,:,:) - vv(:,irup,:,:)
    case( 3 ); t1(:,:,1,:) = vv(:,:,irup+1,:) - vv(:,:,irup,:)
    end select
    f1 = sqrt( sum( t1 * t1, 4 ) )
    sl = sl + dt * f1
    psv = max( psv, f1 )
    if ( svtol > 0.0 ) then
        where ( f1 >= svtol .and. trup > 1e8 )
            trup = tm - dt * ( 0.5 + (svtol - f1) / (f2 - f1) )
        end where
        where ( f1 >= svtol )
            tarr = 1e9
        end where
        where ( f1 < svtol .and. f2 >= svtol )
            tarr = tm - dt * ( 0.5 + (svtol - f1) / (f2 - f1) )
        end where
    end if
    select case( ifn )
    case( 1 ); t2(1,:,:,:) = uu(irup+1,:,:,:) - uu(irup,:,:,:)
    case( 2 ); t2(:,1,:,:) = uu(:,irup+1,:,:) - uu(:,irup,:,:)
    case( 3 ); t2(:,:,1,:) = uu(:,:,irup+1,:) - uu(:,:,irup,:)
    end select
    f2 = sqrt( sum( t2 * t2, 4 ) )
    call fieldio( '>', 'sv1',  t1(:,:,:,1) )
    call fieldio( '>', 'sv2',  t1(:,:,:,2) )
    call fieldio( '>', 'sv3',  t1(:,:,:,3) )
    call fieldio( '>', 'svm',  f1          )
    call fieldio( '>', 'psv',  psv         )
    call fieldio( '>', 'su1',  t2(:,:,:,1) )
    call fieldio( '>', 'su2',  t2(:,:,:,2) )
    call fieldio( '>', 'su3',  t2(:,:,:,3) )
    call fieldio( '>', 'sum',  f2          )
    call fieldio( '>', 'sl',   sl          )
    call fieldio( '>', 'trup', trup        )
    call fieldio( '>', 'tarr', tarr        )
    call set_halo( f1,   -1.0, i1core, i2core )
    call set_halo( f2,   -1.0, i1core, i2core )
    call set_halo( tarr, -1.0, i1core, i2core )
    svmax = maxval( f1 )
    sumax = maxval( f2 )
    slmax = maxval( sl )
    tarrmax = maxval( tarr )
end if

end subroutine
end module

! Stress calculation
module m_stress
implicit none
contains

subroutine stress
use m_globals
use m_diffnc
use m_source
use m_util
use m_fieldio
use m_stats
integer :: i1(3), i2(3), i, j, k, l, ic, iid, id, p

if ( verb ) write( 0, * ) 'Stress'

! Modified displacement
do i = 1, 3
    w1(:,:,:,i) = uu(:,:,:,i) + gam * vv(:,:,:,i)
end do
call set_halo( s1, 0.0, i1cell, i2cell )

! Loop over component and derivative direction
doic: do ic  = 1, 3
doid: do iid = 1, 3; id = modulo( ic + iid - 1, 3 ) + 1

! Elastic region: g_ij = (u_i + gamma*v_i),j
i1 = max( i1pml + 1, i1cell )
i2 = min( i2pml - 2, i2cell )
call diffnc( s1, w1, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )

! PML region, non-damped directions: g_ij = u_i,j
do i = 1, 3
if ( id /= i ) then
    i1 = i1cell
    i2 = i2cell
    i2(i) = min( i2(i), i1pml(i) )
    call diffnc( s1, uu, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    i1 = i1cell
    i2 = i2cell
    i1(i) = max( i1(i), i2pml(i) - 1 )
    call diffnc( s1, uu, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
end if
end do

! PML region, damped direction: g'_ij = d_j*g_ij = v_i,j
select case( id )
case( 1 )
    i1 = i1cell
    i2 = i2cell
    i2(1) = min( i2(1), i1pml(1) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do j = i1(1), i2(1)
        i = j - i1(1) + 1
        p = j + nnoff(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g1(i,k,l,ic)
            g1(i,k,l,ic) = s1(j,k,l)
        end do
        end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(1) = max( i1(1), i2pml(1) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do j = i1(1), i2(1)
        i = i2(1) - j + 1
        p = nn(1) - j - nnoff(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g4(i,k,l,ic)
            g4(i,k,l,ic) = s1(j,k,l)
        end do
        end do
    end do
case( 2 )
    i1 = i1cell
    i2 = i2cell
    i2(2) = min( i2(2), i1pml(2) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do k = i1(2), i2(2)
        i = k - i1(2) + 1
        p = k + nnoff(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g2(j,i,l,ic)
            g2(j,i,l,ic) = s1(j,k,l)
        end do
        end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(2) = max( i1(2), i2pml(2) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do k = i1(2), i2(2)
        i = i2(2) - k + 1
        p = nn(2) - k - nnoff(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g5(j,i,l,ic)
            g5(j,i,l,ic) = s1(j,k,l)
        end do
        end do
    end do
case( 3 )
    i1 = i1cell
    i2 = i2cell
    i2(3) = min( i2(3), i1pml(3) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do l = i1(3), i2(3)
        i = l - i1(3) + 1
        p = l + nnoff(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g3(j,k,i,ic)
            g3(j,k,i,ic) = s1(j,k,l)
        end do
        end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(3) = max( i1(3), i2pml(3) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do l = i1(3), i2(3)
        i = i2(3) - l + 1
        p = nn(3) - l - nnoff(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            s1(j,k,l) = dc2(p) * s1(j,k,l) + dc1(p) * g6(j,k,i,ic)
            g6(j,k,i,ic) = s1(j,k,l)
        end do
        end do
    end do
end select

! Add contribution to potency
i = 6 - ic - id
if ( ic < id ) then
    w2(:,:,:,i) = 0.5 * s1
elseif ( ic > id ) then
    w2(:,:,:,i) = w2(:,:,:,i) + 0.5 * s1
else
    w1(:,:,:,ic) = s1
end if

end do doid
end do doic

! Strain
do i = 1, 3
    w1(:,:,:,i) = w1(:,:,:,i) * vc
    w2(:,:,:,i) = w2(:,:,:,i) * vc
end do

! Add potency source to strain
if ( source == 'potency' ) then
    call finite_source
    call tensor_point_source
end if

! Strain I/O
call fieldio( '<>', 'e11', w1(:,:,:,1) )
call fieldio( '<>', 'e22', w1(:,:,:,2) )
call fieldio( '<>', 'e33', w1(:,:,:,3) )
call fieldio( '<>', 'e23', w2(:,:,:,1) )
call fieldio( '<>', 'e31', w2(:,:,:,2) )
call fieldio( '<>', 'e12', w2(:,:,:,3) )

! Attenuation
!do j = 1, 2
!do k = 1, 2
!do l = 1, 2
!  i = j + 2 * ( k - 1 ) + 4 * ( l - 1 )
!  z1(j::2,k::2,l::2,:) = c1(i) * z1(j::2,k::2,l::2,:) + c2(i) * w1(j::2,k::2,l::2,:)
!  z2(j::2,k::2,l::2,:) = c1(i) * z2(j::2,k::2,l::2,:) + c2(i) * w2(j::2,k::2,l::2,:)
!end do
!end do
!end do

! Hooke's Law: w_ij = lam*g_ij*delta_ij + mu*(g_ij + g_ji)
if ( eplasticity == 'plastic' ) then 
    w1 = w1 - ep1
    w2 = w2 - ep2
end if

s1 = w1(:,:,:,1) + w1(:,:,:,2) + w1(:,:,:,3)

do i = 1, 3
    w1(:,:,:,i) = 2.0 * mu * w1(:,:,:,i) + lam * s1
    w2(:,:,:,i) = 2.0 * mu * w2(:,:,:,i)
end do

! Add moment source to stress
if ( source == 'moment' ) then
    call finite_source
    call tensor_point_source
end if

if ( eplasticity == 'plastic' ) then 

w1 = w1 + si1
w2 = w2 + si2

s1 = w1(:,:,:,1) + w1(:,:,:,2) + w1(:,:,:,3)
s2 = 0.

do i = 1, 3
    z1(:,:,:,i) = w1(:,:,:,i) - s1 / 3.
    z2(:,:,:,i) = w2(:,:,:,i)
    s2 = s2 + z1(:,:,:,i) * z1(:,:,:,i) + 2.0 * z2(:,:,:,i) * z2(:,:,:,i)
end do

s2 = sqrt( 0.5 * s2 )
call invert( s2 )
r3 = - s1 / 3.0 * sin( phi ) + mco * cos( phi )
r3 = r3 * s2

if ( tv > 1.e-6 ) then
   s2 = r3 + ( 1.0 - r3 ) * exp( - dt / tv )
else
   s2 = r3
end if

do i = 1, 3
    r1 = z1(:,:,:,i)
    r2 = z2(:,:,:,i)
    where ( r3 < 1.0 )
        r4 = r1 * s2 
        r5 = r2 * s2
        r1 = r1 - r4
        r2 = r2 - r5
    elsewhere
        r4 = r1
        r5 = r2
        r1 = 0.0
        r2 = 0.0
    end where

    dep1(:,:,:,i) = 0.5 * r1 * mur 
    dep2(:,:,:,i) = 0.5 * r2 * mur 

    w1(:,:,:,i) = s1 / 3.0 + r4
    w2(:,:,:,i) = r5
end do

s2 = 0.0
do i = 1, 3
    s2 = s2 + dep1(:,:,:,i) * dep1(:,:,:,i) + 2.0 * dep2(:,:,:,i) * dep2(:,:,:,i)
end do
epm = epm + sqrt( 2.0 / 3.0 * s2 )

call fieldio( '<>', 'epm', epm )

ep1 = ep1 + dep1
ep2 = ep2 + dep2

w1 = w1 - si1
w2 = w2 - si2

end if

if ( ivols == 'yes' ) then
    z1 = w1 + si1
    z2 = w2 + si2 
 
    call fieldio( '<>', 'w11', z1(:,:,:,1) )
    call fieldio( '<>', 'w22', z1(:,:,:,2) )
    call fieldio( '<>', 'w33', z1(:,:,:,3) )
    call fieldio( '<>', 'w23', z2(:,:,:,1) )
    call fieldio( '<>', 'w31', z2(:,:,:,2) )
    call fieldio( '<>', 'w12', z2(:,:,:,3) )
else
    call fieldio( '<>', 'w11', w1(:,:,:,1) )
    call fieldio( '<>', 'w22', w1(:,:,:,2) )
    call fieldio( '<>', 'w33', w1(:,:,:,3) )
    call fieldio( '<>', 'w23', w2(:,:,:,1) )
    call fieldio( '<>', 'w31', w2(:,:,:,2) )
    call fieldio( '<>', 'w12', w2(:,:,:,3) )
end if

if ( modulo( it, itstats ) == 0 ) then
    call tensor_norm( s1, w1, w2, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    wmax = maxval( s1 )
end if
call fieldio( '>', 'wm2', s1  )

end subroutine

end module

! Acceleration calculation
module m_acceleration
implicit none
contains

subroutine acceleration
use m_globals
use m_diffcn
use m_source
use m_hourglass
use m_bc
use m_rupture
use m_util
use m_fieldio
use m_stats
use m_collective
integer :: i1(3), i2(3), i, j, k, l, ic, iid, id, iq, p
real :: rr

if ( verb ) write( 0, * ) 'Acceleration'
call set_halo( s1, 0.0, i1node, i2node )

! Loop over component and derivative direction
doic: do ic  = 1, 3
doid: do iid = 1, 3; id = modulo( ic + iid - 2, 3 ) + 1

! Elastic region
! f_i = w_ij,j
i1 = i1node
i2 = i2node
if ( ic == id ) then
    call diffcn( s1, w1, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
else
    i = 6 - ic - id
    call diffcn( s1, w2, i, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
end if

! PML region
! p'_ij + d_j*p_ij = w_ij,j (no summation convention)
! f_i = sum_j( p_ij' )
select case( id )
case( 1 )
    do j = i1(1), min( i2(1), i1pml(1) )
        i = j - i1(1) + 1
        p = j + nnoff(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p1(i,k,l,ic)
            p1(i,k,l,ic) = p1(i,k,l,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
    do j = max( i1(1), i2pml(1) ), i2(1)
        i = i2(1) - j + 1
        p = nn(1) - j - nnoff(1) + 1
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p4(i,k,l,ic)
            p4(i,k,l,ic) = p4(i,k,l,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
case( 2 )
    do k = i1(2), min( i2(2), i1pml(2) )
        i = k - i1(2) + 1
        p = k + nnoff(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p2(j,i,l,ic)
            p2(j,i,l,ic) = p2(j,i,l,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
    do k = max( i1(2), i2pml(2) ), i2(2)
        i = i2(2) - k + 1
        p = nn(2) - k - nnoff(2) + 1
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p5(j,i,l,ic)
            p5(j,i,l,ic) = p5(j,i,l,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
case( 3 )
    do l = i1(3), min( i2(3), i1pml(3) )
        i = l - i1(3) + 1
        p = l + nnoff(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p3(j,k,i,ic)
            p3(j,k,i,ic) = p3(j,k,i,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
    do l = max( i1(3), i2pml(3) ), i2(3)
        i = i2(3) - l + 1
        p = nn(3) - l - nnoff(3) + 1
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            s1(j,k,l) = dn2(p) * s1(j,k,l) + dn1(p) * p6(j,k,i,ic)
            p6(j,k,i,ic) = p6(j,k,i,ic) + dt * s1(j,k,l)
        end do
        end do
    end do
end select
 
! Add contribution to force vector
if ( ic == id ) then
    w1(:,:,:,ic) = s1
else
    w1(:,:,:,ic) = w1(:,:,:,ic) + s1
end if

end do doid
end do doic

! Hourglass control. Only viscous in PML
if ( any( hourglass > 0.0 ) ) then
call set_halo( s1, 0.0, i1cell, i2cell )
call set_halo( s2, 0.0, i1node, i2node )
w2 = hourglass(1) * uu + dt * hourglass(2) * vv
do iq = 1, 4
do ic = 1, 3
    i1 = max( i1pml,     i1cell )
    i2 = min( i2pml - 1, i2cell )
    call hourglassnc( s1, w2, iq, ic, i1, i2 )
    s1 = yy * s1
    i1 = max( i1pml + 1, i1node )
    i2 = min( i2pml - 1, i2node )
    call hourglasscn( s2, s1, iq, i1, i2 )
    if ( hourglass(2) > 0.0 .and. npml > 0 ) then
        do i = 1, 3
            i1 = i1cell
            i2 = i2cell
            i2(i) = min( i2(i), i1pml(i) )
            call hourglassnc( s1, vv, iq, ic, i1, i2 )
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                s1(j,k,l) = dt * hourglass(2) * yy(j,k,l) * s1(j,k,l)
            end do
            end do
            end do
            i1 = i1cell
            i2 = i2cell
            i1(i) = max( i1(i), i2pml(i) - 1 )
            call hourglassnc( s1, vv, iq, ic, i1, i2 )
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                s1(j,k,l) = dt * hourglass(2) * yy(j,k,l) * s1(j,k,l)
            end do
            end do
            end do
        end do
        do i = 1, 3
            i1 = i1node
            i2 = i2node
            i2(i) = min( i2(i), i1pml(i) )
            call hourglasscn( s2, s1, iq, i1, i2 )
            i1 = i1node
            i2 = i2node
            i1(i) = max( i1(i), i2pml(i) )
            call hourglasscn( s2, s1, iq, i1, i2 )
        end do
    end if
    w1(:,:,:,ic) = w1(:,:,:,ic) - s2
end do
end do
end if

! Add source to force
if ( source == 'force' ) then
    call finite_source
    call vector_point_source
end if

! Nodal force input
call fieldio( '<', 'f1', w1(:,:,:,1) )
call fieldio( '<', 'f2', w1(:,:,:,2) )
call fieldio( '<', 'f3', w1(:,:,:,3) )

! Boundary conditions
call vector_bc( w1, bc1, bc2, i1bc, i2bc )

! Spontaneous rupture
call rupture

! Swap halo
rr = timer( 2 )
call vector_swap_halo( w1, nhalo )
if (sync) call barrier
mptimer = mptimer + timer( 2 )

! Nodal force output
call fieldio( '>', 'f1', w1(:,:,:,1) )
call fieldio( '>', 'f2', w1(:,:,:,2) )
call fieldio( '>', 'f3', w1(:,:,:,3) )

! Newton's law: a_i = f_i / m
do i = 1, 3
    w1(:,:,:,i) = w1(:,:,:,i) * mr
end do

! Acceleration I/O
call fieldio( '<>', 'a1', w1(:,:,:,1) )
call fieldio( '<>', 'a2', w1(:,:,:,2) )
call fieldio( '<>', 'a3', w1(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, w1, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    amax = maxval( s1 )
end if
call fieldio( '>', 'am2', s1  )

end subroutine

end module

! SORD main program
program sord

! Modules
use m_collective
use m_globals
use m_parameters
use m_setup
use m_arrays
use m_grid_gen
use m_fieldio
use m_material
use m_source
use m_rupture
use m_inivolstress
use m_resample
use m_checkpoint
use m_timestep
use m_stress
use m_acceleration
use m_util
use m_stats
implicit none
integer :: jp = 0, fh(9)
real :: prof0(14) = 0.0
real, allocatable :: prof(:,:)

! Initialization
iotimer = 0.0
prof0(1) = timer(0)
call initialize( np0, ip ); master = ip == 0      ; prof0(1)  = timer(6)
call read_parameters                              ; prof0(2)  = timer(6)
call setup               ; if (sync) call barrier ; prof0(3)  = timer(6)
if ( master ) write( 0, * ) 'SORD - Support Operator Rupture Dynamics'
call look_for_checkpoint ; if (sync) call barrier ; prof0(4)  = timer(6)
call arrays              ; if (sync) call barrier ; prof0(5)  = timer(6)
call grid_gen            ; if (sync) call barrier ; prof0(6)  = timer(6)
call material            ; if (sync) call barrier ; prof0(7)  = timer(6)
call pml                 ; if (sync) call barrier ; prof0(8)  = timer(6) 
call finite_source_init  ; if (sync) call barrier ; prof0(9)  = timer(6)
call rupture_init        ; if (sync) call barrier ; prof0(10) = timer(6)
call resample            ; if (sync) call barrier ; prof0(11) = timer(6)
call read_checkpoint     ; if (sync) call barrier ; prof0(12) = timer(6)
fh = -1
if ( mpout /= 0 ) fh = file_null
allocate( prof(8,itio) )
prof0(13) = iotimer
prof0(14) = timer(7)
if ( master ) call rio1( fh(9), prof0, 'w', 'prof/main', 16, 0, mpout, verb )
prof0(14) = timer(7)

! Main loop
if ( master ) write( 0, * ) 'Main loop:', nt, ' steps'
loop: do while ( it < nt )
it = it + 1
jp = jp + 1
mptimer = 0.0
iotimer = 0.0
prof(1,jp) = timer(5)
call timestep            ; if (sync) call barrier ; prof(1,jp) = timer(5)
call stress              ; if (sync) call barrier ; prof(2,jp) = timer(5)
call acceleration        ; if (sync) call barrier ; prof(3,jp) = timer(5)
call stats               ; if (sync) call barrier ; prof(4,jp) = timer(5)
call write_checkpoint    ; if (sync) call barrier ; prof(5,jp) = timer(5)
prof(6,jp) = mptimer
prof(7,jp) = iotimer
prof(8,jp) = timer(6)
if ( it == nt .or. modulo( it, itio ) == 0 ) then
    if ( master ) then
        call rio1( fh(1), prof(1,:jp), 'w', 'prof/1time',   nt, it-jp, mpout, verb )
        call rio1( fh(2), prof(2,:jp), 'w', 'prof/2stress', nt, it-jp, mpout, verb )
        call rio1( fh(3), prof(3,:jp), 'w', 'prof/3accel',  nt, it-jp, mpout, verb )
        call rio1( fh(4), prof(4,:jp), 'w', 'prof/4stats',  nt, it-jp, mpout, verb )
        call rio1( fh(5), prof(5,:jp), 'w', 'prof/5ckpt',   nt, it-jp, mpout, verb )
        call rio1( fh(6), prof(6,:jp), 'w', 'prof/6mp',     nt, it-jp, mpout, verb )
        call rio1( fh(7), prof(7,:jp), 'w', 'prof/7io',     nt, it-jp, mpout, verb )
        call rio1( fh(8), prof(8,:jp), 'w', 'prof/8step',   nt, it-jp, mpout, verb )
        open( 1, file='currentstep', status='replace' )
        write( 1, * ) it
        close( 1 )
    end if
    jp = 0
end if
if ( master .and. it == itstop ) stop
end do loop

! Finish up
if ( sync ) call barrier
prof0(1) = timer(7)
prof0(2) = timer(8)
if ( master ) then
    call rio1( fh(9), prof0(:2), 'w', 'prof/main', 16, 14, mpout, verb )
    write( 0, * ) 'Finished!'
end if
call finalize
end program

